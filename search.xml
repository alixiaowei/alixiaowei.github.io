<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bugku-变量1]]></title>
    <url>%2F2019%2F01%2F25%2F201919%2F</url>
    <content type="text"><![CDATA[变量1-writeup点击访问链接得到一串php代码提示1234567891011121314&lt;?php error_reporting(0); //关闭错误报告（报错不显示）include "flag1.php"; //引用flag1.php文件代码highlight_file(__file__); //语法高亮if(isset($_GET['args']))&#123; //检查变量是否声明 $args = $_GET['args']; //赋值给变量$args if(!preg_match("/^\w+$/",$args))&#123; //!preg_match 不匹配, ^匹配字符串的开始，\w匹配字母或数字或下划线或汉字等价于'[^A-Za-z0-9_]',$匹配字符串的结束 这里达到过滤作用。 die("args error!"); //输出args error!并退出当前脚本 &#125; eval("var_dump($$args);");//eval()将字符串作为php代码执行,var_dump()函数 打印变量的相关信息,显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。$$args可变变量&#125;?&gt; 12345678910可变变量（Variable variables）可变变量是一种独特的变量，他允许动态改变一个变量的名称。其工作原理是该变量的名称由另外一个变量的值来确定，实现过程就是在变量的前面再多加一个美元符号“$”。下面举一个例子，实例代码如下：&lt;?php$args = "xiaowei"; //声明变量$args$xiaowei = "www.axiaowei.cn"; //声明变量$xiaoweiecho $args; //输出变量$argsecho "\n"; //换行echo $$args; //通过可变变量输出$xiaowei的值?&gt; 再看提示的第一句话flag in the variable! （#flag在变量中）上述的可变变量简单来说$args的值是另一个变量的变量名。那么$$args就代表另一个变量。所以我们就给args赋值一个变量名我们测试php的中的超全局变量，将其变量名传入1234567891011超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量超全局变量:$GLOBALS：[一个包含了全部变量的全局组合数组]$_SERVER:[是预定义服务器变量的一种,所有$_SERVER开头的都是预定义服务变量]$_GET：[用于获取url地址栏的参数数据]$_POST： [用于接收post提交的数据]$_FILES：[用于文件就收的处理img 最常见]$_COOKIE： [用于获取与setCookie()中的name 值]$_SESSION： [用于存储session的值或获取session中的值]$_REQUEST：[具有get,post的功能，但比较慢]$_ENV：[ 是一个包含服务器端环境变量的数组。它是PHP中一个超级全局变量，我们可以在PHP 程序的任何地方直接访问它] 直接构造payload：?args=BLOBLAS]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-本地包含]]></title>
    <url>%2F2019%2F01%2F25%2F201918%2F</url>
    <content type="text"><![CDATA[本地包含-writeup访问链接，显示123，查看源代码，没有任何提示，尝试了几个常见的本地包含的姿势，输入什么都是123,也不报错，并没有什么用试着用御剑扫描一下，出来了个flag.php（没有的可以自己往字典里加）访问flag出来了（很迷？？？）个人感觉这个环境应该是已经玩坏了-_-!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-你必须让他停下]]></title>
    <url>%2F2019%2F01%2F24%2F201917%2F</url>
    <content type="text"><![CDATA[你必须让他停下-writeup打开题目点击访问链接，无限刷新，查看源代码发现js中，如下：12345function myrefresh()&#123; //声明一个函数window.location.reload(); //重新加载当前文档。&#125;setTimeout('myrefresh()',500); //在指定得毫秒数（500）调用函数1000毫秒 = 1秒 你也可以跟我一样，那么准，当显示10.jpg（大概有15张jpg）得页面得时候按pc上的ESC，让页面停止，按F12查看flag想其flag显示在页面上可以把标签中得style=”display:none”中去掉就可以了（并没有什么用，能得到flag就可以了）12display:none将元素的显示设为无，即在网页中不占任何的位置。 我讲一下其他几种方式吧，毕竟上面得操作有点看手速[掩面]view-source 可以利用view-source:查看源代码，然后在当前页面一直刷新（F5），直到flag出现。 抓包工具(这里我用得是burp suite)抓取到页面，发送到Repeater，一直点击go，很快就会出现得]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-域名解析]]></title>
    <url>%2F2019%2F01%2F24%2F201916%2F</url>
    <content type="text"><![CDATA[域名解析-writeup打开题目：首先打开链接，访问显示404根据题目要求把flag.baidu.com解析到123.206.87.240应该就可以拿到flagWindows平台修改C:\Windows\System32\drivers\etc下得hosts文件添加一条解析记录（如果出现修改权限不足的问题，可以利用替换）然后访问flag.baidu.com就可以看到flag了。Linux平台（如kali）直接编辑etc/hosts文件添加一条解析记录一样，直接访问flag.baidu.com就可以到flag了 12hostHosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-一个普通的压缩包(xp0intCTF)]]></title>
    <url>%2F2019%2F01%2F23%2F201911%2F</url>
    <content type="text"><![CDATA[一个普通的压缩包(xp0intCTF)-writeup打开题目下载得到一个rar压缩包附件，解压打开发现还有一个flag.rar，文件属性，详细信息各种查看确定没有隐藏信息，进行再次解压出现提示png文件损坏先打开里面的文本看一下，文本内容提示flag is not here，现在把flag.rar放在十六进制工具里看下，发现里面有一张secret.png文件，但是之前提示损坏了，刚开始用winrar自带的修复功能修复不成功，只能自己用010Editor进行手动修复了。检查rar头，没有问题，然后再看加密部分，检查各个文件的文件头12文件头（FILE_HEAD）HEAD_TYPE 1 个字节 头类型：0x74 更多可以点击RAR文件格式研究我们回到我们的题目中来，检查发现png那的文件头类型A8 3C 7A，把7A修改为74，保存，查看是否修复成功。得到secret.png，查看一张纯白的图片，用010Editor查看是一个gif的文件1GIF文件头标识 (6 bytes) 47 49 46 38 39(37) 61—— GIF89(7)a 修改为gif用stegsolve查看得到gif的两帧每一帧有半张二维码(这里也可以用Photoshop进行分离图层)123456StegSolveAnalyse下面几个功能键作简单介绍：File Format:文件格式，这个主要是查看图片的具体信息Data Extract:数据抽取，图片中隐藏数据的抽取Frame Browser:帧浏览器，主要是对GIF之类的动图进行分解，动图变成一张张图片，便于查看Image Combiner:拼图，图片拼接 用Photoshop将这两块进行拼接成完整的二维码，利用QR扫描（手机扫也一样的）得到flag二维码的生成细节和原理有兴趣的可以去了解下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[zip文件格式说明]]></title>
    <url>%2F2019%2F01%2F22%2F201914%2F</url>
    <content type="text"><![CDATA[zip文件格式zip文件由三部分组成：压缩的文件内容源数据、压缩的目录源数据、目录结束标识的结构①压缩文件内容的源数据：记录着压缩的所有文件的内容信息，其数据组织结构是对于每个文件都由File header 、File data 、 Data descriptor 三部分组成。File header（文件头）：用于标识该文件的开始，结构说明如下：File data(文件数据)：相应压缩文件的源数据。Data descriptor（数据描述符）：用于标识该文件压缩结束，该结构只有在相应的local file header中通用标记字段的第３bit设为１时才会出现，紧接在压缩文件源数据后。这个数据描述符只用在不能对输出的 ZIP 文件进行检索时使用。例如：在一个不能检索的驱动器（如：磁带机上）上的 ZIP 文件中。如果是磁盘上的ZIP文件一般没有这个数据描述符。②Central directory 核心目录记录了压缩文件的目录信息，在这个数据区中每一条记录对应再压缩源文件数据区中的一条数据。核心目录结构：③End of central directory record(EOCD) 目录结束标识目录结束标识存于整个归档包的结尾，用于标记压缩目录数据的结束。每个压缩文件必须有且只有一个EOCD记录。 官方文档：https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt]]></content>
  </entry>
  <entry>
    <title><![CDATA[zip压缩包--加密破解篇]]></title>
    <url>%2F2019%2F01%2F22%2F201915%2F</url>
    <content type="text"><![CDATA[伪加密、爆破、明文攻击、CRC32碰撞zip文件格式：zip文件由三部分组成：压缩的文件内容源数据、压缩的目录元数据、目录结束标识结构详情点击：zip格式说明zip伪加密若是没有加密的zip文件，两处标记都是00 00如果是加密的zip文件，两处都标记的是09 00（注意不同的压缩软件有差异，有些好像是01 00）若将未加密的zip文件中的压缩源文件目录区的全局方式位标记改为01 00 （或者09 00），就会被压缩软件认为已加密，这就是所谓的伪加密了破解伪加密的zip，只要把压缩文件目录区的全局方式标记改为00 00 （除windows外的系统（如kali）可直接打开伪加密压缩包）爆破爆破：逐个尝试选定集合中的可以组成的所有密码，直到遇到正确的密码。分为暴力破解、掩码破解、字典破解这几种1、暴力破解：选择密码范围，长度等，由软件组合生成密码进行破解2、掩码破解：知道密码中的一部分，只需要按照规则构造其余部分进行破解3、字典破解：通常是多数用户常用的一些密码集合，导入字典文件用字典中的密码进行破解（取决你的字典）这里可以使用Windows下的一款神器AZPR，也可以自己动手用python写个爆破的脚本。明文攻击明文攻击（Known plaintext attack）：是一种攻击模式，指攻击者已知明文、密文及算法，求密钥的过程。明文攻击是一种较为高效的攻击手段，如：当你不知道一个zip压缩包文件的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有压缩文件使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。简单来说就是，zip明文攻击就是利用已知文件找到加密密钥，利用密钥来解释其他加密文件，因为zip压缩包里的所有文件都是使用同一个加密密钥来加密的。这里举个例子：现在我压缩了带密码的四个文件，已知明文攻击测试.zip中的明文攻击.docx进行对已知文件进行压缩，对比crc值是否跟加密文件中的crc值一致利用AZPR进行明文攻击成功获取到密文注意：当明文的大小比较小时，或者密文过长，攻击速度会比较慢；即使有时没有恢复密码，也可以使用明文攻击，最后点保存还是能得到压缩包里内容的，如果出现错误可以多试几款压缩软件。CRC32碰撞CRC32：CRC本身是“冗余校验码”的意思，CRC32则标识会产生一个32bit（8位十六进制）的校验值。 CRC校验实用程序库，在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC的全称是循环冗余校验。 在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件中的内容。 每个文件都有唯一的CRC32值，即便数据中一个bit发生变化，也会导致CRC32值不同。若是知道一段数据的长度和CRC32值，便可穷举数据，与其CRC32对照，以此达到暴力猜解的目的。但限于CPU的能力，通常只适用于较小文本文件。 案例：可以参考我写的Bugku-好多压缩包那篇文章。bugku中的例子脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243# coding:utf-8import binasciiimport stringimport zipfileimport base64dicts = string.printable # 可打印字符的字符串。ascii码33-126号def collision_crc(crc): global out_file for a in dicts: for b in dicts: for c in dicts: for d in dicts: strings = a + b + c + d strings = strings.encode('utf-8') if crc == (binascii.crc32(strings)): out_file.write(strings.decode('utf-8')) # print(strings) return # 以上定义一个方法，组合随机字符与CRC进行碰撞，判断如果相等及写入文件def obtain_zip(): for i in range(68): file = 'out' + str(i) + '.zip' zip_file = zipfile.ZipFile(file, 'r') # 读取创建zip_file对象 get_crc = zip_file.getinfo('data.txt') # 压缩文件夹里的data.txt文件，获取文档内指定的文件信息 crc = get_crc.CRC # 以上定义一个方法，获取68个zip的CRC的值 collision_crc(crc) # 再调用collision方法传参out_file = open('out.txt', 'w')obtain_zip()out_file.close()out_file2 = open('out.txt', 'r')with open('flag.rar', 'wb') as rar: rar.write(base64.b64decode(out_file2.read())) # 二进制将转换后的base64位写入文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-好多压缩包]]></title>
    <url>%2F2019%2F01%2F21%2F201906%2F</url>
    <content type="text"><![CDATA[好多压缩包-writeup打开题目得到一个压缩包附件，进行解压，查看到里面有68个压缩包打开68个文件发现里面每个压缩包里都有一个四个字节大小的txt文档（加密），首先尝试下是不是伪加密，发现不是尝试下爆破无果。。。然后想了下，这么多压缩包，不可能让我们爆破吧，尝试下crc32碰撞CRC32碰撞可以参考我写的文章zip压缩包–加密篇**分析里面得文件得四个字节，想着应该是英文，中文字符得话跟爆破没区别…猜测里面为四个字符（英文），获取zip文件得crc32值，进行crc碰撞碰撞出来发现是一串base64，拿去解密(有些网站解码不了，解码了也是有问题的，多尝试几个)，放入winhex，发现导入进去的时候老是有问题，我不知道怎么处理，莫名其妙的多了很多空格，搜索了下感觉他们很顺利的就放进去了尝试多次发现无果。然后无奈就自己写python实现直接base64解密后直接写入文件里python脚本：12345678910111213141516171819202122232425262728293031323334353637383940414243# coding:utf-8import binasciiimport stringimport zipfileimport base64dicts = string.printable # 可打印字符的字符串。ascii码33-126号def collision_crc(crc): global out_file for a in dicts: for b in dicts: for c in dicts: for d in dicts: strings = a + b + c + d strings = strings.encode('utf-8') if crc == (binascii.crc32(strings)): out_file.write(strings.decode('utf-8')) # print(strings) return # 以上定义一个方法，组合随机字符与CRC进行碰撞，判断如果相等及写入文件def obtain_zip(): for i in range(68): file = 'out' + str(i) + '.zip' zip_file = zipfile.ZipFile(file, 'r') # 读取创建zip_file对象 get_crc = zip_file.getinfo('data.txt') # 压缩文件夹里的data.txt文件，获取文档内指定的文件信息 crc = get_crc.CRC # 以上定义一个方法，获取68个zip的CRC的值 collision_crc(crc) # 再调用collision方法传参 out_file = open('out.txt', 'w')obtain_zip()out_file.close()out_file2 = open('out.txt', 'r')with open('flag.rar', 'wb') as rar: rar.write(base64.b64decode(out_file2.read())) # 二进制将转换后的base64位写入文件 运行完成后将写出的文件，打开发现打开失败，导入16进制编辑器，观察数据，发现存在rar的文件尾C4 3D 7B 00 40 07 00，但缺少文件头，于是补上rar的文件头52 61 72 21 1A 07 00，发现文件修复成功，解压发现是一个flag在压缩包注释上。二进制上也可以看到CMT，CMT即为comment（注释） 这里说明下我之前base64导入进去的出现的问题，因为心里一直纳闷，所以去多次尝试发现需要利用notepad++32位的进行base64解密，就可以得到正确的值，保存为.rar文件，然后进行导入十六进制编辑工具里是可以实现的。（之前用的时notepad++64位的会出现解密不出来的情况，几个在线工具解密出来的值都是错误的或者跟上面导进去不知道为什么多了很多空格这些）这里举几个对比：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-怀疑人生]]></title>
    <url>%2F2019%2F01%2F20%2F201907%2F</url>
    <content type="text"><![CDATA[怀疑人生–wirteup打开题目得到一个附件，发现是zip的文件头，直接在后缀上加上一个.zip。解压，发现三个文件。第一个需要解压密码，先看下其他文件有没有其他hint直接丢进kali，分析一波，分离ctf2.jpg得到一个压缩包解压，里面存在一个txt文本，发现一串加密得密文Brainfuck/Ook!编码，拿去Ook解密来看这个奇怪得二维码，直接那QR扫以下看下有什么信息，得到内容折腾了挺久也好像没有其他信息了，字典破解，尝试下，还真有！解压得到一串base64，进行base64解密，得到一串unicode，进行解密解密后进行拼接，提交发现失败，尝试多次，很纳闷，感觉不对劲，中间那Ook解密后感觉还是一个密文，查了一下是一个base58？？？进行解密得到明文，进行ctf1+ctf2+ctf3进行拼接，提交成功。1234567891011121314151617此题出现了几种编码：base64:Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。base58:Base58是用于Bitcoin中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址,相比Base64，Base58不使用数字"0"，字母大写"O"，字母大写"I"，和字母小写"l"，以及"+"和"/"符号.Unicode:Unicode又称（统一码、万国码、单一码）世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。Brainfuck/Ook:Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于fuck在英语中是脏话，这种语言有时被称为brainf*ck或brainf**k，甚至被简称为BF。OOK！是一种为红毛猩猩设计的编程语言。OOK！与众所周知的深奥语言BrainF ***基本上是同构的 ，但语法元素更少。详情可跳转至http://www.dangermouse.net/esoteric/ook.html二维码:二维码又称二维条码，常见的二维码为QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL注入攻击]]></title>
    <url>%2F2019%2F01%2F20%2F201913%2F</url>
    <content type="text"><![CDATA[待更新…..]]></content>
  </entry>
  <entry>
    <title><![CDATA[CBC字节翻转攻击原理]]></title>
    <url>%2F2019%2F01%2F20%2F201912%2F</url>
    <content type="text"><![CDATA[CBC字节翻转攻击原理CBC模式：Cipher Black Chaining mode (密码分组链接模式)CBC模式进行加解密是都需要一个随机初始向量iv，在第一轮进行加解密是都需要与iv进行xor的。 任何字符与本身xor都是为0，任何字符与0xor都为本身，如A xor A=0，A xor 0=A 加密过程1、将明文分为若干组（16个字节为一组），最后一组不足则用特殊字符填充2、生成一个初始向量iv和key密钥3、用iv与第一组明文异或（iv只影响第一组生成的密文）生成密文4、然后再用前n组密文与后n+1组明文异或生成第n+1组密文，以次重复5、最后将生成的密文拼接起来，就成了最终密文加密公式：Ciphertext-0 = Encrypt(Plaintext XOR IV)—只用于第一个组块Ciphertext-N= Encrypt(Plaintext XOR Ciphertext-N-1)—用于第二及剩下的组块 解密过程：1、将密文分组2、用iv与第一组密文xor，解密得到第一组明文3、用第n组密文与第n+1组密文xor，解密得到第n+1组明文，以此类推4、将各组的明文拼接在一起就是最终要得到的明文了 注意一下：解密的时候前一组密文只影响后一组明文的结果，而不会影响其他组明文的结果，由图也可看得出，这个也是进行攻击的重要之处。 有一条经验法则是（注：结合上面的说明图可以得到），你在密文中改变的字节，只会影响到在下一明文当中，具有相同偏移量的字节。所以我们目标的偏移量是2：CBC字节翻转攻击原理图http://processon.com/chart_image/5c37fd8de4b0db2e59306630.png123456XOR异或运算异或，英文为exclusive OR，缩写成xor异或的数学符号为“⊕”异或略称为XOR、EOR、EX-OR程序中有三种演算子：XOR、xor、⊕。两个输入相同时为0，不同则为1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-论剑]]></title>
    <url>%2F2019%2F01%2F20%2F201909%2F</url>
    <content type="text"><![CDATA[论剑-writeup因为很少人做出来，导致网上很少这个wp（找不到），所以我在这里记录下解题思路打开题目访问链接，把图片下载下来另存为先把它丢进kali上binwalk扫描以下，发现有隐藏文件，foremost直接分离出来，得到两张图片把图片都拿去二进制编辑工具查看下，在原图上搜索下FFD9（jpg的结束标识），发现有两个，以及一段二进制文件，很可疑这段二进制拿去转ASCII码，得到mynameiskey!!!hhh 折腾了下，暂时先放着。什么详细信息、备注都毫无hint，想着修改图片高度看下，发现新大陆，但是隐藏了一部分-_-!把分离出来的图片都修改高度，发现跟原图一样，无果天坑，这里想打si作者的环节，在分离出来的两张图片，以及这段这段二进制狂下功夫，xor、盲水印、色道分析..折腾了一段时间并没有什么用查看二进制那段信息发现，看到BC AF 27 1C好熟悉，好像特征码给改过，尝试修改,修复文件头12345678910111213141516171819常见的文件头：7z文件头标识：37 7A BC AF 27 1CJPEG/JPG文件头标识: ff, d8 (SOI) (JPEG 文件标识) 文件结束标识: ff, d9 (EOI) PNG文件头标识：89 50 4E 47 0D 0A 1A 0AGIF文件头标识：47 49 46 38 39(37) 61--- GIF89(7)aBMP文件头标识：42 4D--- BMHTML (html)文件头标识：68746D6C3E ZIP Archive (zip)文件头标识：504B0304 --- PKRAR Archive (rar)文件头标识：52617221 等等.. 丢回kali用binwalk分析，发现多了一个压缩包，分离，注意使用foremost分离不出来，利用dd分离出来123456使用dd命令分离文件，如:dd if=hehe.jpg of=hehe1.zip bs=1 skip=54163if=file（源文件）of=file（输出文件）bs=bytes（一次性转换bytes个字节，及转换缓冲区大小）skip=blocks（输入文件开头跳过blocks个块再开始复制--通俗点讲就是从哪开始） 进行解压，需要密码，用二进制转的ASCII码进行解密，得到一张图片，修改高度，得到另一部分的flag，进行拼接最终得到一个的密文这个不是md5，是一个base16密文，进行base16解密，得到flag]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web3]]></title>
    <url>%2F2019%2F01%2F20%2F201904%2F</url>
    <content type="text"><![CDATA[web3-writeup打开题目点击访问链接，无限弹窗好了，我点烦了，粗暴点直接按（Ctrl+u）直接强制查看源码，也可以自己直接使用view-source:URL，查看源码。得到一段Unicode编码，Burp Suite直接解码，也可以在线的工具，百度一下很多的。123Unicode编码：Unicode码扩展自ASCII字元集。Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-矛盾]]></title>
    <url>%2F2019%2F01%2F20%2F201910%2F</url>
    <content type="text"><![CDATA[矛盾-writeup打开题目访问链接，得到一串代码，又是一道代码审计的题12345678//代码分析$num=$_GET['num']; //Get方式获取参数if(!is_numeric($num)) //is_numeric()函数是否为数字或者数字字符串-&gt;&gt;加个！取反,通俗点讲这里不能为数字&#123;echo $num; //如果不是数字就输出if($num==1) //矛盾吧，上面又不要数字，这里又要是1echo 'flag&#123;**********&#125;'; //如果值为1则输出flag&#125; 根据提示，可以用科学计数法表示1，构造URL：?num=1e0.1 既不是纯数字，其值又等于1 其实还有很多种姿势获取到flag，授人以鱼不如授人以渔。以下讲解几个特征。12345678910php是一个弱类型语言==表示的是等于 ，比较两个变量的值，不比较数据类型。只要数值等于就成立了===表示的是全等，比较的是两个变量的值和类型== 判断时，当数字与字符串比较时，系统先将字符串转化为数字，再与数字进行比较。is_numeric（）函数用于检测变量是否为数字或数字字符串。is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，怎么构造有思路了吗？PHP浅谈==和===：https://blog.csdn.net/auuuuuuuu/article/details/79621635科学计数法：https://baike.baidu.com/item/科学记数法/1612882?fr=aladdin]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web基础$_POST]]></title>
    <url>%2F2019%2F01%2F19%2F201905%2F</url>
    <content type="text"><![CDATA[web基础$_POST-writeup打开题目，这是一道简单的post题还是老规矩，点击访问链接，提示给出一串代码，分析代码，一道简单的代码审计。1234$what=$_POST['what']; //post提交数据赋值给变量echo $what;if($what=='flag') //判断post提交的数据是否等于flag，如果true输出flagecho 'flag&#123;****&#125;'; 我们只要post提交的变量what=falg就可以了，这里用一款熟悉的插件工具HackBak点击Execute提交，flag就出来了。1POST提交：向指定的资源提交要被处理的数据。 浅析get与post的区别：定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE（查、改、增、删）四个操作。对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。 GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连。 POST把提交的数据则放置在是HTTP包的包体中。POST的安全性要比GET的安全性高。 get是从服务器上获取数据，post是向服务器传送数据。get 和 post只是一种传递数据的方式，get也可以把数据传到服务器，他们的本质都是发送请求和接收结果。只是组织格式和数据量上面有差别，GET和POST只是发送机制不同，并不是一个取一个发！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web基础$_GET]]></title>
    <url>%2F2019%2F01%2F19%2F201901%2F</url>
    <content type="text"><![CDATA[web基础$_GET-writeup点击访问链接，分析给出的代码1234$what=$_GET['what']; //Get方式获取参数echo $what; if($what=='flag') //这里有个if判断当what的值等于flag时就输出flagecho 'flag&#123;****&#125;'; 分析完代码，我们直接在URL中，后面直接加上?what=flag，Get请求123Get请求：从指定的资源请求数据。GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接。URL中的?号：分隔实际的URL和参数]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-color]]></title>
    <url>%2F2019%2F01%2F19%2F201903%2F</url>
    <content type="text"><![CDATA[color-writeup打开题目点击链接，得到一个压缩包附件，解压打开，7张png格式的图片，哇!你有见过彩虹吗？利用Stegsolve查看每张图片的最低位，发现有变化，组合起来Make Me Tall根据提示的意思，应该需要改变图片的高度发现图片下方有黑白格子，按照黑格子-&gt;1,白格子-&gt;0，转成二进制123456711111111010111101111111110111111101111110000110010101011000101001010010000001101110100110111010101111001101101101011011000111001101101111101 经过几次尝试后发现，这里每一列(巨坑)，七个数字组成一个字符，进行二进制转化ascii码得到flagpython3脚本：12345678910111213141516# coding:utf-8# Bug_ku color# 七张图片下方的黑白格子转换的二进制color1 = '11111111010111101111'color2 = '11111011111110111111'color3 = '00001100101010110001'color4 = '01001010010000001101'color5 = '11010011011101010111'color6 = '10011011011010110110'color7 = '00111001101101111101'# 循环根据下标组合成每一列的二进制for i in range(0, 20): color = color1[i]+color2[i]+color3[i]+color4[i]+color5[i]+color6[i]+color7[i] print(chr(int(color, 2)), end='') # 打印转换后的ASCII码 PNG文件头知识：1234567（固定）八个字节：89 50 4E 47 0D 0A 1A 0A 代表着PNG文件头（固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13，描述IHDR头部的大小（固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH）（可变）紧接着13位数据块（IHDR) -前四个字节代表该图片的宽（Width） -后四个字节代表该图片的高（Height） -后五个字节依次为：Bit depth、ColorType、Compression method、Filter method、Interlace method]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-计算器]]></title>
    <url>%2F2019%2F01%2F19%2F201908%2F</url>
    <content type="text"><![CDATA[计算器-writeup查看题目，访问题目给出的链接查看是一个随机数字运算的验证码，输入结果值发现最大只能输入一位长度的值点击提交看看有什么结果，并没有什么用！浏览器上按F12,审核元素，查看源代码，发现maxlength=”1”,把maxlength=”1”修改为maxlength=”2”把结果值填上，点击验证得到flag 我发现一个骚姿势就是，只要你够耐心的话一直点击刷新，会有意向不到的结果1234567HTML input maxlength属性定义和用法 maxlength 属性规定 &lt;input&gt; 元素中允许的最大字符数。 语法 &lt;input maxlength="number"&gt; 属性值 number 在&lt;input&gt;元素中允许的最大字符串]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web2]]></title>
    <url>%2F2019%2F01%2F19%2F201902%2F</url>
    <content type="text"><![CDATA[web2-writeup可能会写的有点啰嗦，但是我不想跟我一样入门的小白看到教程一脸？？？这是一道20分值的简单题，听说聪明的人都能找到答案直接访问链接这是一个满屏滑稽的页面在浏览器当前页面上直接按F12审查元素，查看源代码，查看到flag也可以利用view-source:sURL查看源代码，查看到flag12345F12:开发人员工具，是开发人员调试利器~ view-source:是一种协议，早在基本上每个浏览器都支持这个协议。后来Microsoft考虑安全性，对于windows pack2以及更高的版本后IE就不再支持此协议。但是这个方法在FireFox和Chrome浏览器还可以使用。 使用方法： view-source:sURL 回车即可看到当前网页的源代码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[勿忘初心]]></title>
    <url>%2F2019%2F01%2F18%2F2019%2F</url>
    <content type="text"><![CDATA[努力努力再努力Hello,Blog!]]></content>
  </entry>
</search>
